<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFL Madden Optimizer - DraftKings</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0d0f12;
            --bg-secondary: #14171c;
            --bg-tertiary: #1a1e24;
            --bg-card: #1e2229;
            --bg-hover: #262b33;
            --bg-input: #12151a;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a9;
            --text-muted: #5f6672;
            --accent-primary: #10b981;
            --accent-secondary: #6366f1;
            --accent-tertiary: #f59e0b;
            --accent-danger: #ef4444;
            --accent-cyan: #22d3ee;
            --border-color: #2a2f38;
            --border-light: #363c47;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            --gradient-green: linear-gradient(135deg, #10b981, #059669);
            --gradient-purple: linear-gradient(135deg, #6366f1, #4f46e5);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
        }

        /* Header */
        .header {
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 32px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .logo span {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* Main Container */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px 32px;
        }

        /* Stats Row */
        .stats-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 18px;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
        }

        .stat-card.green::before { background: var(--gradient-green); }
        .stat-card.purple::before { background: var(--gradient-purple); }
        .stat-card.amber::before { background: linear-gradient(90deg, #f59e0b, #d97706); }
        .stat-card.cyan::before { background: linear-gradient(90deg, #22d3ee, #06b6d4); }
        .stat-card.red::before { background: linear-gradient(90deg, #ef4444, #dc2626); }

        .stat-card-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .stat-card-value {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .stat-card-value.positive { color: var(--accent-primary); }

        .stat-card-sub {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Card */
        .card {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 24px;
        }

        .card-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--bg-tertiary);
        }

        .card-title {
            font-size: 0.9rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .card-title svg {
            width: 18px;
            height: 18px;
            color: var(--accent-primary);
        }

        .card-body {
            padding: 20px;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--gradient-green);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: var(--bg-hover);
            border-color: var(--border-light);
        }

        .btn-lg {
            padding: 14px 28px;
            font-size: 1rem;
        }

        .btn-all {
            width: 100%;
            margin-top: 10px;
            padding: 14px 24px;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
        }

        .btn-all:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .btn-all:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-all svg {
            width: 18px;
            height: 18px;
        }

        .btn-all svg.spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Upload Zone */
        .upload-zone {
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.2s;
            cursor: pointer;
            background-color: var(--bg-tertiary);
        }

        .upload-zone:hover {
            border-color: var(--accent-primary);
            background-color: rgba(16, 185, 129, 0.05);
        }

        .upload-zone.dragover {
            border-color: var(--accent-primary);
            background-color: rgba(16, 185, 129, 0.1);
        }

        .upload-zone svg {
            width: 48px;
            height: 48px;
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .upload-zone h3 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .upload-zone p {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .upload-zone input {
            display: none;
        }

        .file-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background-color: var(--bg-input);
            border-radius: 8px;
            margin-top: 16px;
        }

        .file-info svg {
            width: 20px;
            height: 20px;
            color: var(--accent-primary);
        }

        .file-info span {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .file-info .remove-file {
            margin-left: auto;
            color: var(--accent-danger);
            cursor: pointer;
            padding: 4px;
        }

        /* Grid */
        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
        }

        /* Settings */
        .settings-group {
            margin-bottom: 20px;
        }

        .settings-label {
            font-size: 0.8rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: block;
        }

        .settings-row {
            display: flex;
            gap: 8px;
        }

        .lineup-count-btn {
            flex: 1;
            padding: 12px 16px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lineup-count-btn:hover {
            border-color: var(--border-light);
            color: var(--text-primary);
        }

        .lineup-count-btn.active {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .lineup-time-btn {
            flex: 1;
            padding: 12px 16px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lineup-time-btn:hover {
            border-color: var(--border-light);
            color: var(--text-primary);
        }

        .lineup-time-btn.active {
            background-color: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
            color: white;
        }

        /* Pagination */
        .pagination-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background-color: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .pagination {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pagination-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination-btn:hover:not(:disabled) {
            background-color: var(--bg-hover);
            border-color: var(--border-light);
            color: var(--text-primary);
        }

        .pagination-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 0.85rem;
            color: var(--text-primary);
            font-weight: 500;
            min-width: 100px;
            text-align: center;
        }

        .pagination-showing {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Slider Styles */
        .slider-group {
            margin-bottom: 20px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .slider-values {
            font-size: 0.85rem;
            color: var(--accent-primary);
            font-weight: 600;
        }

        .slider-value-highlight {
            font-size: 0.9rem;
            color: var(--accent-tertiary);
            font-weight: 700;
            background: rgba(245, 158, 11, 0.15);
            padding: 4px 10px;
            border-radius: 4px;
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 6px;
        }

        .slider-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            font-style: italic;
        }

        /* Dual Range Slider */
        .dual-slider-container {
            position: relative;
            height: 24px;
        }

        .slider-track {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
        }

        .slider-range {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 6px;
            background: var(--gradient-green);
            border-radius: 3px;
        }

        .dual-slider {
            position: absolute;
            top: 0;
            width: 100%;
            height: 24px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            pointer-events: none;
        }

        .dual-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
            transition: transform 0.15s;
        }

        .dual-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .dual-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
            pointer-events: all;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        /* Single Slider */
        .single-slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(to right, var(--accent-tertiary) 100%, var(--bg-input) 100%);
            border-radius: 3px;
            outline: none;
        }

        .single-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent-tertiary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
            transition: transform 0.15s;
        }

        .single-slider::-webkit-slider-thumb:hover {
            transform: scale(1.15);
        }

        .single-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: var(--accent-tertiary);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border: 2px solid white;
        }

        /* Entries Section */
        .entries-summary {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 0.85rem;
        }

        .entries-summary span {
            color: var(--text-muted);
        }

        .entry-fee-total {
            color: var(--accent-primary) !important;
            font-weight: 600;
        }

        .entries-grouped-container {
            max-height: 600px;
            overflow-y: auto;
        }

        /* Optimization Section */
        .optimize-banner {
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%);
            border-bottom: 1px solid var(--border-color);
        }

        .optimize-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .optimize-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 1rem;
            font-weight: 700;
            color: var(--text-primary);
        }

        .optimize-title svg {
            width: 22px;
            height: 22px;
            color: var(--accent-primary);
        }

        .optimize-status {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .optimize-status.success {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .optimize-settings {
            display: flex;
            align-items: flex-end;
            gap: 24px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .optimize-mode-group {
            flex: 1;
            min-width: 300px;
        }

        .optimize-mode-label {
            display: block;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-weight: 600;
        }

        .optimize-modes {
            display: flex;
            gap: 8px;
        }

        .optimize-mode-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .optimize-mode-btn svg {
            width: 16px;
            height: 16px;
        }

        .optimize-mode-btn:hover {
            background-color: var(--bg-hover);
            border-color: var(--border-light);
        }

        .optimize-mode-btn.active {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .optimize-options {
            display: flex;
            gap: 16px;
        }

        .optimize-option {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .optimize-option label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            font-weight: 600;
        }

        .optimize-input {
            width: 70px;
            padding: 8px 10px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
        }

        .optimize-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .btn-optimize {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            padding: 14px 24px;
            background: var(--gradient-green);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .btn-optimize svg {
            width: 20px;
            height: 20px;
        }

        .btn-optimize:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .btn-optimize:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .optimize-buttons {
            display: flex;
            gap: 12px;
        }

        .optimize-buttons .btn-optimize {
            flex: 1;
        }

        .btn-export {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 14px 24px;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
            white-space: nowrap;
        }

        .btn-export svg {
            width: 18px;
            height: 18px;
        }

        .btn-export:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(99, 102, 241, 0.4);
        }

        .btn-export:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Paw Patrol Settings */
        .paw-patrol-settings {
            margin-top: 16px;
            padding: 16px;
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.1), rgba(245, 158, 11, 0.05));
            border: 1px solid rgba(251, 191, 36, 0.3);
            border-radius: 10px;
        }

        .paw-patrol-header {
            display: flex;
            align-items: center;
            margin-bottom: 14px;
        }

        .paw-patrol-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #fbbf24;
        }

        .diversity-slider-container {
            margin-bottom: 12px;
        }

        .diversity-slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .diversity-slider-header label {
            font-size: 0.85rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .diversity-value {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            color: #1a1a2e;
            font-weight: 700;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.85rem;
        }

        .diversity-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .diversity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
            transition: transform 0.2s;
        }

        .diversity-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .diversity-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(251, 191, 36, 0.4);
        }

        .diversity-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 6px;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .diversity-hint {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            font-style: italic;
        }

        .portfolio-summary {
            margin-top: 14px;
            padding-top: 14px;
            border-top: 1px solid rgba(251, 191, 36, 0.2);
        }

        .portfolio-summary-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .portfolio-exposure-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .exposure-item {
            display: flex;
            align-items: center;
            gap: 4px;
            background: var(--bg-tertiary);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .exposure-name {
            color: var(--text-secondary);
            max-width: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .exposure-pct {
            color: #fbbf24;
            font-weight: 600;
        }

        .exposure-item.high {
            background: rgba(239, 68, 68, 0.15);
        }

        .exposure-item.high .exposure-pct {
            color: #ef4444;
        }

        .exposure-item.medium {
            background: rgba(251, 191, 36, 0.15);
        }

        .exposure-item.low {
            background: rgba(16, 185, 129, 0.15);
        }

        .exposure-item.low .exposure-pct {
            color: #10b981;
        }

        /* Contest Groups - Clean Design */
        .contest-group {
            border-bottom: 1px solid var(--border-color);
        }

        .contest-group:last-child {
            border-bottom: none;
        }

        .contest-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 20px;
            background-color: var(--bg-tertiary);
        }

        .contest-group-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .contest-group-icon {
            width: 32px;
            height: 32px;
            background: var(--gradient-green);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .contest-group-icon svg {
            width: 16px;
            height: 16px;
            color: white;
        }

        .contest-group-icon.cash {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }

        .game-type-badge {
            font-size: 0.65rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 4px 10px;
            border-radius: 4px;
            margin-left: 10px;
        }

        .game-type-badge.cash {
            background-color: rgba(245, 158, 11, 0.15);
            color: #fbbf24;
        }

        .game-type-badge.gpp {
            background-color: rgba(99, 102, 241, 0.15);
            color: #a5b4fc;
        }

        .contest-group-name {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .contest-group-stats {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.8rem;
        }

        .contest-group-stats span {
            color: var(--text-muted);
        }

        .contest-group-stats .dot {
            color: var(--border-light);
        }

        .contest-group-fee {
            font-weight: 700;
            color: var(--accent-primary) !important;
        }

        /* Entries Table - Clean & Readable */
        .contest-entries-table {
            width: 100%;
            border-collapse: collapse;
        }

        .contest-entries-table th {
            text-align: left;
            padding: 10px 16px;
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            background-color: var(--bg-secondary);
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
        }

        .contest-entries-table td {
            padding: 12px 16px;
            font-size: 0.85rem;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-card);
        }

        .contest-entries-table tr:last-child td {
            border-bottom: none;
        }

        .contest-entries-table tr:hover td {
            background-color: var(--bg-hover);
        }

        .entry-fee-cell {
            font-weight: 700;
            color: var(--accent-tertiary);
            font-size: 0.8rem;
        }

        .entry-player {
            color: var(--text-primary);
            font-weight: 500;
        }

        .entry-player.cpt {
            color: var(--accent-tertiary);
            font-weight: 600;
        }

        .entry-pos {
            color: var(--text-muted);
            font-size: 0.7rem;
            margin-left: 6px;
            font-weight: 500;
        }

        .entry-salary-cell {
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.8rem;
            text-align: right;
        }

        .entry-proj-cell {
            font-weight: 700;
            color: var(--accent-primary);
            font-size: 0.9rem;
            text-align: right;
        }

        /* Player Pool Table */
        .table-container {
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: left;
            padding: 12px 16px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-tertiary);
            font-weight: 600;
            position: sticky;
            top: 0;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            color: var(--text-primary);
        }

        th.sortable::after {
            content: '⇅';
            margin-left: 6px;
            opacity: 0.5;
        }

        th.sort-asc::after {
            content: '↑';
            opacity: 1;
            color: var(--accent-primary);
        }

        th.sort-desc::after {
            content: '↓';
            opacity: 1;
            color: var(--accent-primary);
        }

        td {
            padding: 12px 16px;
            font-size: 0.85rem;
            border-bottom: 1px solid var(--border-color);
        }

        tr:hover {
            background-color: var(--bg-hover);
        }

        tr:last-child td {
            border-bottom: none;
        }

        /* Position Badge */
        .position-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .position-badge.qb { background-color: rgba(239, 68, 68, 0.15); color: #ef4444; }
        .position-badge.rb { background-color: rgba(16, 185, 129, 0.15); color: #10b981; }
        .position-badge.wr { background-color: rgba(59, 130, 246, 0.15); color: #3b82f6; }
        .position-badge.te { background-color: rgba(245, 158, 11, 0.15); color: #f59e0b; }
        .position-badge.k { background-color: rgba(139, 92, 246, 0.15); color: #8b5cf6; }
        .position-badge.dst { background-color: rgba(236, 72, 153, 0.15); color: #ec4899; }
        .position-badge.cpt { background-color: rgba(251, 191, 36, 0.25); color: #fbbf24; border: 1px solid rgba(251, 191, 36, 0.5); }
        .position-badge.flex { background-color: rgba(107, 114, 128, 0.15); color: #9ca3af; }

        /* Team Badge */
        .team-badge {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-weight: 500;
        }

        /* Lineup Card */
        .lineup-row {
            display: grid;
            grid-template-columns: 60px repeat(6, 1fr) 100px 100px;
            gap: 8px;
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            font-size: 0.85rem;
        }

        .lineup-row:hover {
            background-color: var(--bg-hover);
        }

        .lineup-row.header {
            background-color: var(--bg-tertiary);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .lineup-row.header .sortable {
            cursor: pointer;
            transition: color 0.2s;
        }

        .lineup-row.header .sortable:hover {
            color: var(--accent-primary);
        }

        .lineup-row.header .sortable.sort-asc,
        .lineup-row.header .sortable.sort-desc {
            color: var(--accent-primary);
        }

        .lineup-rank {
            font-weight: 700;
            color: var(--accent-tertiary);
        }

        .lineup-player {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .lineup-player-name {
            font-weight: 500;
            font-size: 0.8rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .lineup-player-meta {
            font-size: 0.65rem;
            color: var(--text-muted);
        }

        .lineup-salary {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .lineup-points {
            font-weight: 700;
            color: var(--accent-primary);
        }

        /* Progress */
        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            height: 8px;
            background-color: var(--bg-input);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-green);
            border-radius: 4px;
            transition: width 0.3s;
        }

        .progress-text {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-align: center;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        .empty-state h4 {
            font-size: 1rem;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }

        .empty-state p {
            font-size: 0.85rem;
        }

        /* Slate Selector */
        .slate-selector {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        .slate-btn {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 10px 8px;
            background-color: var(--bg-input);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .slate-btn:hover {
            background-color: var(--bg-hover);
            border-color: var(--border-light);
        }

        .slate-btn .slate-num {
            font-size: 1.1rem;
            font-weight: 700;
        }

        .slate-btn .slate-time {
            font-size: 0.65rem;
            opacity: 0.7;
        }

        .slate-btn.loaded {
            background-color: rgba(16, 185, 129, 0.1);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .slate-btn.active {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        .slate-btn.active .slate-time {
            opacity: 0.9;
        }

        .current-slate-info {
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
            display: none;
        }

        .current-slate-info.visible {
            display: block;
        }

        .slate-info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slate-info-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .slate-badge {
            background: var(--gradient-green);
            color: white;
            font-size: 0.8rem;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 6px;
        }

        .slate-details {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .slate-details .teams {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .slate-details .datetime {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .slate-info-right {
            display: flex;
            gap: 16px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .slate-info-right span {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .slate-info-right .count {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Section Slate Badge - shows current slate in each section header */
        .section-slate-badge {
            display: none;
            background: var(--gradient-green);
            color: white;
            font-size: 0.7rem;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 4px;
            margin-left: 10px;
        }

        .section-slate-badge.visible {
            display: inline-block;
        }

        /* Lineup Output Container */
        .lineup-output {
            max-height: 600px;
            overflow-y: auto;
        }

        /* Classic Lineup Output (9 positions) */
        .classic-lineup-output {
            max-height: 600px;
            overflow-y: auto;
        }

        .classic-lineup-row {
            display: grid;
            grid-template-columns: 50px repeat(9, 1fr) 80px 80px;
            gap: 4px;
            padding: 10px 12px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            font-size: 0.75rem;
        }

        .classic-lineup-row:hover {
            background-color: var(--bg-hover);
        }

        .classic-lineup-row.header {
            background-color: var(--bg-tertiary);
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .classic-lineup-row.header .sortable {
            cursor: pointer;
            transition: color 0.2s;
        }

        .classic-lineup-row.header .sortable:hover {
            color: var(--accent-primary);
        }

        .classic-player {
            display: flex;
            flex-direction: column;
            gap: 1px;
            min-width: 0;
        }

        .classic-player-name {
            font-weight: 500;
            font-size: 0.7rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .classic-player-info {
            font-size: 0.6rem;
            color: var(--text-muted);
        }

        .classic-lineup-salary {
            font-weight: 600;
            color: var(--accent-primary);
        }

        .classic-lineup-score {
            font-weight: 700;
            color: var(--accent-tertiary);
        }

        .classic-lineup-rank {
            font-weight: 700;
            color: var(--accent-tertiary);
            text-align: center;
        }

        .score-breakdown {
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .score-proj {
            font-size: 0.7rem;
            font-weight: 600;
        }

        .score-corr {
            font-size: 0.55rem;
            color: var(--text-muted);
        }

        .score-corr.positive {
            color: var(--accent-primary);
        }

        .score-corr.negative {
            color: var(--accent-danger);
        }

        /* Export Button */
        .export-section {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Loading Spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--bg-tertiary);
            border-top-color: var(--accent-primary);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Checkbox */
        .checkbox-cell {
            width: 40px;
        }

        .checkbox {
            width: 16px;
            height: 16px;
            accent-color: var(--accent-primary);
            cursor: pointer;
        }

        /* Filter Pills */
        .filter-pills {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .filter-pill {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            cursor: pointer;
            background-color: var(--bg-input);
            color: var(--text-secondary);
            transition: all 0.2s;
            border: 1px solid var(--border-color);
        }

        .filter-pill:hover {
            border-color: var(--border-light);
            color: var(--text-primary);
        }

        .filter-pill.active {
            background-color: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        /* Rules Info */
        .rules-info {
            background-color: var(--bg-tertiary);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .rules-info h4 {
            font-size: 0.85rem;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        .rules-list {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .rules-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .rules-item svg {
            width: 14px;
            height: 14px;
            color: var(--accent-primary);
        }

        /* Search */
        .search-input {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            margin-bottom: 16px;
        }

        .search-input input {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 0.85rem;
            outline: none;
            flex: 1;
        }

        .search-input input::placeholder {
            color: var(--text-muted);
        }

        .search-input svg {
            width: 16px;
            height: 16px;
            color: var(--text-muted);
        }

        /* Main Tab Navigation */
        .main-tabs {
            display: flex;
            background-color: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 0 32px;
        }

        .main-tab {
            padding: 14px 24px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .main-tab:hover {
            color: var(--text-primary);
            background-color: var(--bg-tertiary);
        }

        .main-tab.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
        }

        .main-tab svg {
            width: 18px;
            height: 18px;
        }

        .main-tab .tab-badge {
            background: var(--accent-tertiary);
            color: #000;
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: 700;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Player Data Upload Styles */
        .player-data-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 16px;
        }

        .pd-upload-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s;
        }

        .pd-upload-card.loaded {
            border-color: var(--accent-primary);
        }

        .pd-upload-header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-card);
        }

        .pd-position-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            color: white;
        }

        .pd-position-badge.qb { background: linear-gradient(135deg, #ef4444, #dc2626); }
        .pd-position-badge.rb { background: linear-gradient(135deg, #10b981, #059669); }
        .pd-position-badge.wr { background: linear-gradient(135deg, #3b82f6, #2563eb); }
        .pd-position-badge.te { background: linear-gradient(135deg, #f59e0b, #d97706); }
        .pd-position-badge.dst { background: linear-gradient(135deg, #8b5cf6, #7c3aed); }

        .pd-upload-header span {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .pd-upload-zone {
            padding: 30px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pd-upload-zone:hover {
            background: rgba(16, 185, 129, 0.05);
        }

        .pd-upload-zone.dragover {
            background: rgba(16, 185, 129, 0.1);
        }

        .pd-upload-zone svg {
            width: 32px;
            height: 32px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .pd-upload-zone span {
            display: block;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .pd-upload-card.loaded .pd-upload-zone svg {
            color: var(--accent-primary);
        }

        .pd-upload-status {
            padding: 10px 16px;
            background: var(--bg-input);
            border-top: 1px solid var(--border-color);
        }

        .pd-status-text {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .pd-upload-card.loaded .pd-status-text {
            color: var(--accent-primary);
        }

        .pd-file-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .pd-file-info .remove-btn {
            color: var(--accent-danger);
            cursor: pointer;
            padding: 2px;
        }

        .pd-file-info .remove-btn:hover {
            opacity: 0.8;
        }

        /* Correlation Table */
        .correlation-table {
            max-height: 400px;
            overflow-y: auto;
        }

        .correlation-row {
            display: grid;
            grid-template-columns: 1fr 1fr 100px 60px;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            font-size: 0.85rem;
        }

        .correlation-row:hover {
            background: var(--bg-tertiary);
        }

        .correlation-row.header {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            position: sticky;
            top: 0;
        }

        .correlation-value {
            font-weight: 600;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
        }

        .correlation-value.positive {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-primary);
        }

        .correlation-value.negative {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-danger);
        }

        .correlation-filter-pills {
            display: flex;
            gap: 8px;
        }

        @media (max-width: 1200px) {
            .player-data-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .player-data-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Position Matrix Styles */
        .position-matrix-container {
            margin-bottom: 24px;
        }

        .position-matrix {
            display: grid;
            grid-template-columns: 60px repeat(5, 1fr);
            gap: 2px;
            background: var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .matrix-cell {
            background: var(--bg-card);
            padding: 12px 8px;
            text-align: center;
            font-size: 0.8rem;
        }

        .matrix-cell.header {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .matrix-cell.row-header {
            background: var(--bg-tertiary);
            font-weight: 600;
            color: var(--text-secondary);
        }

        .matrix-cell.positive {
            background: rgba(16, 185, 129, 0.15);
            color: var(--accent-primary);
            font-weight: 600;
        }

        .matrix-cell.neutral {
            background: var(--bg-card);
            color: var(--text-muted);
        }

        .matrix-cell.negative {
            background: rgba(239, 68, 68, 0.15);
            color: var(--accent-danger);
            font-weight: 600;
        }

        .matrix-cell.empty {
            background: var(--bg-input);
            color: var(--text-muted);
        }

        /* Team Cards Grid */
        .team-cards-container {
            margin-top: 24px;
        }

        .team-cards-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
        }

        .team-card {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.2s;
            cursor: pointer;
        }

        .team-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .team-card-header {
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 3px solid;
        }

        .team-logo {
            width: 40px;
            height: 40px;
            object-fit: contain;
        }

        .team-info h4 {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .team-info span {
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .team-card-body {
            padding: 12px 16px;
        }

        .team-corr-section {
            margin-bottom: 10px;
        }

        .team-corr-section:last-child {
            margin-bottom: 0;
        }

        .team-corr-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .team-corr-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
            font-size: 0.8rem;
        }

        .team-corr-item .player-name {
            color: var(--text-secondary);
        }

        .team-corr-item .corr-value {
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .team-corr-item .corr-value.positive {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-primary);
        }

        .team-corr-item .corr-value.negative {
            background: rgba(239, 68, 68, 0.2);
            color: var(--accent-danger);
        }

        /* Team Detail Modal */
        .team-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s;
        }

        .team-detail-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .team-detail-modal {
            background: var(--bg-card);
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
            transform: translateY(20px);
            transition: all 0.2s;
        }

        .team-detail-overlay.active .team-detail-modal {
            transform: translateY(0);
        }

        .team-detail-header {
            padding: 20px 24px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 3px solid;
        }

        .team-detail-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .team-detail-header .team-logo {
            width: 60px;
            height: 60px;
        }

        .team-detail-header h2 {
            font-size: 1.3rem;
            font-weight: 700;
        }

        .team-detail-close {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .team-detail-close:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .team-detail-body {
            padding: 24px;
            max-height: calc(80vh - 100px);
            overflow-y: auto;
        }

        .team-detail-section {
            margin-bottom: 24px;
        }

        .team-detail-section:last-child {
            margin-bottom: 0;
        }

        .team-detail-section h3 {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .detail-corr-list {
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
        }

        .detail-corr-row {
            display: grid;
            grid-template-columns: 1fr 1fr 80px 50px;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border-color);
            align-items: center;
            font-size: 0.85rem;
        }

        .detail-corr-row:last-child {
            border-bottom: none;
        }

        .detail-corr-row:hover {
            background: var(--bg-hover);
        }

        .corr-bar-container {
            width: 100%;
            height: 6px;
            background: var(--bg-input);
            border-radius: 3px;
            overflow: hidden;
        }

        .corr-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s;
        }

        .corr-bar.positive {
            background: var(--accent-primary);
        }

        .corr-bar.negative {
            background: var(--accent-danger);
        }

        /* Position Pair Tabs */
        .position-pair-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .position-pair-tab {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .position-pair-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .position-pair-tab.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: white;
        }

        @media (max-width: 1200px) {
            .team-cards-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 900px) {
            .team-cards-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 600px) {
            .team-cards-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="logo">
            <svg width="28" height="28" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <h1>NFL Madden Optimizer</h1>
            <span>DraftKings</span>
        </div>
        <div class="header-right">
            <div id="fileStatus" style="font-size: 0.85rem; color: var(--text-muted);">No file loaded</div>
        </div>
    </header>

    <!-- Main Tab Navigation -->
    <nav class="main-tabs">
        <div class="main-tab active" data-tab="showdown">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            Madden SD
        </div>
        <div class="main-tab" data-tab="classic">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
            </svg>
            Madden Classic
        </div>
        <div class="main-tab" data-tab="playerdata">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
            Player Data
        </div>
    </nav>

    <!-- Showdown Tab Content -->
    <div class="tab-content active" id="showdownTab">

    <!-- Main Container -->
    <div class="container">
        <!-- Stats Row -->
        <div class="stats-row">
            <div class="stat-card green">
                <div class="stat-card-label">DK Entries</div>
                <div class="stat-card-value" id="entriesLoaded">0</div>
                <div class="stat-card-sub">Contest entries</div>
            </div>
            <div class="stat-card purple">
                <div class="stat-card-label">Players Loaded</div>
                <div class="stat-card-value" id="playersLoaded">0</div>
                <div class="stat-card-sub">From CSV</div>
            </div>
            <div class="stat-card cyan">
                <div class="stat-card-label">Lineups Generated</div>
                <div class="stat-card-value" id="lineupsGenerated">0</div>
                <div class="stat-card-sub">Optimized</div>
            </div>
            <div class="stat-card amber">
                <div class="stat-card-label">Top Projection</div>
                <div class="stat-card-value positive" id="topProjection">0.00</div>
                <div class="stat-card-sub">Best Lineup</div>
            </div>
            <div class="stat-card red">
                <div class="stat-card-label">Avg Projection</div>
                <div class="stat-card-value" id="avgProjection">0.00</div>
                <div class="stat-card-sub">All Lineups</div>
            </div>
        </div>

        <!-- Upload & Settings Section -->
        <div class="grid-2">
            <!-- Upload Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                        Upload DraftKings Export
                    </div>
                </div>
                <div class="card-body">
                    <!-- Slate Selector -->
                    <div class="slate-selector" id="slateSelector">
                        <button class="slate-btn" data-slate="1">
                            <span class="slate-num">1</span>
                            <span class="slate-time">12:00</span>
                        </button>
                        <button class="slate-btn" data-slate="2">
                            <span class="slate-num">2</span>
                            <span class="slate-time">2:00</span>
                        </button>
                        <button class="slate-btn" data-slate="3">
                            <span class="slate-num">3</span>
                            <span class="slate-time">4:00</span>
                        </button>
                        <button class="slate-btn" data-slate="4">
                            <span class="slate-num">4</span>
                            <span class="slate-time">6:00</span>
                        </button>
                        <button class="slate-btn" data-slate="5">
                            <span class="slate-num">5</span>
                            <span class="slate-time">8:00</span>
                        </button>
                        <button class="slate-btn" data-slate="6">
                            <span class="slate-num">6</span>
                            <span class="slate-time">10:00</span>
                        </button>
                    </div>
                    
                    <!-- Current Slate Info -->
                    <div class="current-slate-info" id="currentSlateInfo">
                        <div class="slate-info-row">
                            <div class="slate-info-left">
                                <div class="slate-badge" id="slateBadge">1</div>
                                <div class="slate-details">
                                    <span class="teams" id="slateTeams">ATL @ TB</span>
                                    <span class="datetime" id="slateDateTime">11/24/2025 12:00 PM ET</span>
                                </div>
                            </div>
                            <div class="slate-info-right">
                                <span><span class="count" id="slatePlayerCount">0</span> players</span>
                                <span><span class="count" id="slateEntryCount">0</span> entries</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="upload-zone" id="uploadZone">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                        <h3>Drop your DraftKings CSV here</h3>
                        <p>Entries + Player Pool export file</p>
                        <input type="file" id="csvInput" accept=".csv">
                    </div>
                </div>
            </div>

            <!-- Settings Card -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                        </svg>
                        Optimizer Settings
                    </div>
                </div>
                <div class="card-body">
                    <div class="slider-group">
                        <div class="slider-header">
                            <label class="settings-label">Salary Range</label>
                            <span class="slider-values">$<span id="minSalaryValue">49,000</span> - $<span id="maxSalaryValue">50,000</span></span>
                        </div>
                        <div class="dual-slider-container">
                            <div class="slider-track"></div>
                            <div class="slider-range" id="salaryRange"></div>
                            <input type="range" class="dual-slider" id="minSalarySlider" min="40000" max="50000" value="49000" step="100">
                            <input type="range" class="dual-slider" id="maxSalarySlider" min="40000" max="50000" value="50000" step="100">
                        </div>
                        <div class="slider-labels">
                            <span>$40,000</span>
                            <span>$50,000</span>
                        </div>
                    </div>

                    <div class="slider-group">
                        <div class="slider-header">
                            <label class="settings-label">Projection Floor</label>
                            <span class="slider-value-highlight" id="projFloorValue">90.0%</span>
                        </div>
                        <input type="range" class="single-slider" id="projFloorSlider" min="80" max="100" value="90" step="0.5">
                        <div class="slider-labels">
                            <span>80%</span>
                            <span>100%</span>
                        </div>
                        <p class="slider-hint">Only include lineups within this % of the top projection</p>
                    </div>

                    <div class="settings-group">
                        <label class="settings-label">Number of Lineups to Generate</label>
                        <div class="settings-row">
                            <button class="lineup-count-btn active" data-count="100">100</button>
                            <button class="lineup-count-btn" data-count="500">500</button>
                            <button class="lineup-count-btn" data-count="2000">2,000</button>
                            <button class="lineup-count-btn" data-count="5000">5,000</button>
                        </div>
                    </div>

                    <div class="settings-group">
                        <label class="settings-label">Or Generate for Time Duration</label>
                        <div class="settings-row">
                            <button class="lineup-time-btn" data-seconds="10">10 sec</button>
                            <button class="lineup-time-btn" data-seconds="20">20 sec</button>
                            <button class="lineup-time-btn" data-seconds="30">30 sec</button>
                            <button class="lineup-time-btn" data-seconds="60">1 min</button>
                        </div>
                    </div>

                    <button class="btn btn-primary btn-lg" id="generateBtn" style="width: 100%;" disabled>
                        <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                        </svg>
                        Generate Lineups
                    </button>
                    
                    <button class="btn btn-all" id="processAllBtn">
                        <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                        </svg>
                        ALL
                    </button>

                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                        </div>
                        <div class="progress-text" id="progressText">Generating lineups...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Optimization Section -->
        <div class="card" id="optimizeCard" style="display: none;">
            <div class="optimize-banner">
                <div class="optimize-header">
                    <div class="optimize-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"/>
                        </svg>
                        <span>Entry Optimizer</span>
                    </div>
                    <div class="optimize-status" id="optimizeStatus"></div>
                </div>
                
                <div class="optimize-settings">
                    <div class="optimize-mode-group">
                        <label class="optimize-mode-label">Optimization Mode</label>
                        <div class="optimize-modes">
                            <button class="optimize-mode-btn active" data-mode="balanced" title="GPP entries get unique lineups, Cash entries share top lineup">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                                </svg>
                                Balanced
                            </button>
                            <button class="optimize-mode-btn" data-mode="cash" title="All entries use the highest projected lineup">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                Cash
                            </button>
                            <button class="optimize-mode-btn" data-mode="paw-patrol" title="Portfolio-optimized GPP entries with anti-correlation">
                                🐾 Paw Patrol
                            </button>
                        </div>
                    </div>
                    
                    <div class="optimize-options">
                        <div class="optimize-option">
                            <label>Min Uniques</label>
                            <input type="number" id="minUniques" value="1" min="1" max="6" class="optimize-input">
                        </div>
                    </div>
                </div>
                
                <!-- Paw Patrol Settings (only visible when Paw Patrol mode selected) -->
                <div class="paw-patrol-settings" id="pawPatrolSettings" style="display: none;">
                    <div class="paw-patrol-header">
                        <span class="paw-patrol-title">🐾 Portfolio Optimization Settings</span>
                    </div>
                    <div class="diversity-slider-container">
                        <div class="diversity-slider-header">
                            <label>Diversity Strength</label>
                            <span class="diversity-value" id="diversityValue">5</span>
                        </div>
                        <input type="range" class="diversity-slider" id="diversitySlider" min="0" max="10" value="5" step="1">
                        <div class="diversity-labels">
                            <span>0 (Projection)</span>
                            <span>10 (Diversity)</span>
                        </div>
                        <p class="diversity-hint">Higher values prioritize anti-correlation between your lineups</p>
                    </div>
                    <div class="portfolio-summary" id="portfolioSummary" style="display: none;">
                        <div class="portfolio-summary-title">Portfolio Exposure</div>
                        <div class="portfolio-exposure-list" id="portfolioExposureList"></div>
                    </div>
                </div>
                
                <div class="optimize-buttons">
                    <button class="btn-optimize" id="optimizeBtn" disabled>
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                        </svg>
                        Optimize Entries
                    </button>
                    <button class="btn-export" id="exportEntriesBtn" disabled>
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                        </svg>
                        Export to DraftKings
                    </button>
                </div>
            </div>
        </div>

        <!-- My Entries Section -->
        <div class="card" id="entriesCard" style="display: none;">
            <div class="card-header">
                <div class="card-title">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                    </svg>
                    My DraftKings Entries
                    <span class="section-slate-badge" id="entriesSlateBadge"></span>
                </div>
                <div class="entries-summary">
                    <span id="entriesCount">0 entries</span>
                    <span class="entry-fee-total" id="totalEntryFees">$0.00 total</span>
                </div>
            </div>
            <div class="entries-grouped-container" id="entriesGroupedContainer">
            </div>
        </div>

        <!-- Player Pool -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z"/>
                    </svg>
                    Player Pool
                    <span class="section-slate-badge" id="playerPoolSlateBadge"></span>
                </div>
                <div style="font-size: 0.8rem; color: var(--text-muted);">
                    <span id="playerCount">0</span> players
                </div>
            </div>
            <div class="card-body" style="padding: 16px 20px 0;">
                <div class="filter-pills" id="positionFilters">
                    <span class="filter-pill active" data-pos="all">All</span>
                    <span class="filter-pill" data-pos="QB">QB</span>
                    <span class="filter-pill" data-pos="RB">RB</span>
                    <span class="filter-pill" data-pos="WR">WR</span>
                    <span class="filter-pill" data-pos="TE">TE</span>
                    <span class="filter-pill" data-pos="K">K</span>
                    <span class="filter-pill" data-pos="DST">DST</span>
                </div>
                <div class="search-input">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                    </svg>
                    <input type="text" id="playerSearch" placeholder="Search players...">
                </div>
            </div>
            <div class="table-container" id="playerPoolContainer">
                <div class="empty-state">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                    </svg>
                    <h4>No Players Loaded</h4>
                    <p>Upload a CSV file to load player projections</p>
                </div>
            </div>
        </div>

        <!-- Generated Lineups -->
        <div class="card" id="lineupsCard" style="display: none;">
            <div class="card-header">
                <div class="card-title">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                    </svg>
                    Generated Lineups
                    <span class="section-slate-badge" id="lineupsSlateBadge"></span>
                </div>
                <div class="export-section">
                    <span style="font-size: 0.8rem; color: var(--text-muted);" id="lineupCountDisplay">0 lineups</span>
                    <button class="btn btn-secondary" id="clearLineupsBtn">
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                        </svg>
                        Clear
                    </button>
                    <button class="btn btn-secondary" id="exportBtn">
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                        </svg>
                        Export CSV
                    </button>
                </div>
            </div>
            <div class="pagination-container" id="paginationTop" style="display: none;">
                <div class="pagination">
                    <button class="pagination-btn" id="prevPageTop" disabled>
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                        </svg>
                        Prev
                    </button>
                    <span class="pagination-info" id="pageInfoTop">Page 1 of 1</span>
                    <button class="pagination-btn" id="nextPageTop">
                        Next
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                        </svg>
                    </button>
                </div>
                <span class="pagination-showing" id="showingInfoTop">Showing 1-100</span>
            </div>
            </div>
            <div class="lineup-output" id="lineupOutput">
                <div class="lineup-row header">
                    <div class="sortable" data-sort="rank">Rank ⇅</div>
                    <div>CPT</div>
                    <div>FLEX</div>
                    <div>FLEX</div>
                    <div>FLEX</div>
                    <div>FLEX</div>
                    <div>FLEX</div>
                    <div class="sortable" data-sort="salary">Salary ⇅</div>
                    <div class="sortable sort-desc" data-sort="points">Points ↓</div>
                </div>
                <div id="lineupRows"></div>
            </div>
            <div class="pagination" id="pagination" style="display: none;">
                <button class="btn btn-secondary pagination-btn" id="prevPage" disabled>
                    <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                    </svg>
                    Previous
                </button>
                <div class="pagination-info">
                    <span>Page <strong id="currentPageNum">1</strong> of <strong id="totalPages">1</strong></span>
                    <span class="pagination-range" id="paginationRange">(1-100 of 100)</span>
                </div>
                <button class="btn btn-secondary pagination-btn" id="nextPage">
                    Next
                    <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>
    </div> <!-- End Showdown Tab -->

    <!-- Classic Tab Content -->
    <div class="tab-content" id="classicTab">
        <div class="container">
            <!-- Stats Row -->
            <div class="stats-row">
                <div class="stat-card green">
                    <div class="stat-card-label">DK Entries</div>
                    <div class="stat-card-value" id="classicEntriesLoaded">0</div>
                    <div class="stat-card-sub">Contest entries</div>
                </div>
                <div class="stat-card purple">
                    <div class="stat-card-label">Players Loaded</div>
                    <div class="stat-card-value" id="classicPlayersLoaded">0</div>
                    <div class="stat-card-sub">From CSV</div>
                </div>
                <div class="stat-card cyan">
                    <div class="stat-card-label">Lineups Generated</div>
                    <div class="stat-card-value" id="classicLineupsGenerated">0</div>
                    <div class="stat-card-sub">Optimized</div>
                </div>
                <div class="stat-card amber">
                    <div class="stat-card-label">Top Projection</div>
                    <div class="stat-card-value positive" id="classicTopProjection">0.00</div>
                    <div class="stat-card-sub">Best Lineup</div>
                </div>
                <div class="stat-card red">
                    <div class="stat-card-label">Avg Score</div>
                    <div class="stat-card-value" id="classicAvgScore">0.00</div>
                    <div class="stat-card-sub">Proj + Corr</div>
                </div>
            </div>

            <!-- Upload & Settings Section -->
            <div class="grid-2">
                <!-- Upload Card -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            Upload DraftKings Export
                        </div>
                    </div>
                    <div class="card-body">
                        <!-- Slate Selector -->
                        <!-- Slate Selector - Classic has 2 slates (3 games each) -->
                        <div class="slate-selector" id="classicSlateSelector">
                            <button class="slate-btn" data-slate="1">
                                <span class="slate-num">1</span>
                                <span class="slate-time">Early (12-4)</span>
                            </button>
                            <button class="slate-btn" data-slate="2">
                                <span class="slate-num">2</span>
                                <span class="slate-time">Late (6-10)</span>
                            </button>
                        </div>
                        
                        <!-- Current Slate Info -->
                        <div class="current-slate-info" id="classicCurrentSlateInfo">
                            <div class="slate-info-row">
                                <div class="slate-info-left">
                                    <div class="slate-badge" id="classicSlateBadge">1</div>
                                    <div class="slate-details">
                                        <span class="teams" id="classicSlateTeams">No slate selected</span>
                                        <span class="datetime" id="classicSlateDateTime">Upload CSV to load slates</span>
                                    </div>
                                </div>
                                <div class="slate-info-right">
                                    <span><span class="count" id="classicSlatePlayerCount">0</span> players</span>
                                    <span><span class="count" id="classicSlateEntryCount">0</span> entries</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="upload-zone" id="classicUploadZone">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                            </svg>
                            <h3>Drop your DraftKings CSV here</h3>
                            <p>Entries + Player Pool export file</p>
                            <input type="file" id="classicCsvInput" accept=".csv">
                        </div>
                    </div>
                </div>

                <!-- Settings Card -->
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                            </svg>
                            Optimizer Settings
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="slider-group">
                            <div class="slider-header">
                                <label class="settings-label">Salary Range</label>
                                <span class="slider-values">$<span id="classicMinSalaryValue">45,000</span> - $<span id="classicMaxSalaryValue">50,000</span></span>
                            </div>
                            <div class="dual-slider-container">
                                <div class="slider-track"></div>
                                <div class="slider-range" id="classicSalaryRange"></div>
                                <input type="range" class="dual-slider" id="classicMinSalarySlider" min="40000" max="50000" value="45000" step="100">
                                <input type="range" class="dual-slider" id="classicMaxSalarySlider" min="40000" max="50000" value="50000" step="100">
                            </div>
                            <div class="slider-labels">
                                <span>$40,000</span>
                                <span>$50,000</span>
                            </div>
                        </div>

                        <div class="slider-group">
                            <div class="slider-header">
                                <label class="settings-label">Projection Floor</label>
                                <span class="slider-value-highlight" id="classicProjFloorValue">90.0%</span>
                            </div>
                            <input type="range" class="single-slider" id="classicProjFloorSlider" min="80" max="100" value="90" step="0.5">
                            <div class="slider-labels">
                                <span>80%</span>
                                <span>100%</span>
                            </div>
                            <p class="slider-hint">Only include lineups within this % of the top projection</p>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label">Number of Lineups to Generate</label>
                            <div class="settings-row" id="classicLineupCountBtns">
                                <button class="lineup-count-btn active" data-count="100">100</button>
                                <button class="lineup-count-btn" data-count="500">500</button>
                                <button class="lineup-count-btn" data-count="2000">2,000</button>
                                <button class="lineup-count-btn" data-count="5000">5,000</button>
                            </div>
                        </div>

                        <div class="settings-group">
                            <label class="settings-label">Or Generate for Time Duration</label>
                            <div class="settings-row" id="classicTimeBtns">
                                <button class="lineup-time-btn" data-seconds="10">10 sec</button>
                                <button class="lineup-time-btn" data-seconds="20">20 sec</button>
                                <button class="lineup-time-btn" data-seconds="30">30 sec</button>
                                <button class="lineup-time-btn" data-seconds="60">1 min</button>
                            </div>
                        </div>

                        <button class="btn btn-primary btn-lg" id="classicGenerateBtn" style="width: 100%;" disabled>
                            <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                            </svg>
                            Generate Lineups
                        </button>
                        
                        <button class="btn btn-all" id="classicProcessAllBtn">
                            <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                            </svg>
                            ALL
                        </button>

                        <div class="progress-container" id="classicProgressContainer">
                            <div class="progress-bar">
                                <div class="progress-fill" id="classicProgressFill" style="width: 0%;"></div>
                            </div>
                            <div class="progress-text" id="classicProgressText">Generating lineups...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Entry Optimizer Section -->
            <div class="card" id="classicOptimizeCard" style="display: none;">
                <div class="optimize-banner">
                    <div class="optimize-header">
                        <div class="optimize-title">
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4M7.835 4.697a3.42 3.42 0 001.946-.806 3.42 3.42 0 014.438 0 3.42 3.42 0 001.946.806 3.42 3.42 0 013.138 3.138 3.42 3.42 0 00.806 1.946 3.42 3.42 0 010 4.438 3.42 3.42 0 00-.806 1.946 3.42 3.42 0 01-3.138 3.138 3.42 3.42 0 00-1.946.806 3.42 3.42 0 01-4.438 0 3.42 3.42 0 00-1.946-.806 3.42 3.42 0 01-3.138-3.138 3.42 3.42 0 00-.806-1.946 3.42 3.42 0 010-4.438 3.42 3.42 0 00.806-1.946 3.42 3.42 0 013.138-3.138z"/>
                            </svg>
                            <span>Entry Optimizer</span>
                        </div>
                        <div class="optimize-status" id="classicOptimizeStatus"></div>
                    </div>
                    
                    <div class="optimize-settings">
                        <div class="optimize-mode-group">
                            <label class="optimize-mode-label">Optimization Mode</label>
                            <div class="optimize-modes" id="classicOptimizeModes">
                                <button class="optimize-mode-btn" data-mode="balanced">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                                    </svg>
                                    Balanced
                                </button>
                                <button class="optimize-mode-btn" data-mode="cash">
                                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    Cash
                                </button>
                                <button class="optimize-mode-btn active" data-mode="paw-patrol">
                                    🐾 Paw Patrol
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Paw Patrol Settings -->
                    <div class="paw-patrol-settings" id="classicPawPatrolSettings">
                        <div class="paw-patrol-header">
                            <span class="paw-patrol-title">🐾 Portfolio Optimization Settings</span>
                        </div>
                        <div class="diversity-slider-container">
                            <div class="diversity-slider-header">
                                <label>Diversity Strength</label>
                                <span class="diversity-value" id="classicDiversityValue">5</span>
                            </div>
                            <input type="range" class="diversity-slider" id="classicDiversitySlider" min="0" max="10" value="5" step="1">
                            <div class="diversity-labels">
                                <span>0 (Projection)</span>
                                <span>10 (Diversity)</span>
                            </div>
                            <p class="diversity-hint">Higher values prioritize anti-correlation between your lineups</p>
                        </div>
                    </div>
                    
                    <div class="optimize-buttons">
                        <button class="btn-optimize" id="classicOptimizeBtn" disabled>
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                            </svg>
                            Optimize Entries
                        </button>
                        <button class="btn-export" id="classicExportEntriesBtn" disabled>
                            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                            </svg>
                            Export to DraftKings
                        </button>
                    </div>
                </div>
            </div>

            <!-- My Entries Section -->
            <div class="card" id="classicEntriesCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                        </svg>
                        My DraftKings Entries
                        <span class="section-slate-badge" id="classicEntriesSlateBadge"></span>
                    </div>
                    <div class="entries-summary">
                        <span id="classicEntriesCount">0 entries</span>
                        <span class="entry-fee-total" id="classicTotalEntryFees">$0.00 total</span>
                    </div>
                </div>
                <div class="entries-grouped-container" id="classicEntriesGroupedContainer">
                </div>
            </div>

            <!-- Player Pool -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0z"/>
                        </svg>
                        Player Pool
                        <span class="section-slate-badge" id="classicPlayerPoolSlateBadge"></span>
                    </div>
                    <div style="font-size: 0.8rem; color: var(--text-muted);">
                        <span id="classicPlayerCount">0</span> players
                    </div>
                </div>
                <div class="card-body" style="padding: 16px 20px 0;">
                    <div class="filter-pills" id="classicPositionFilters">
                        <span class="filter-pill active" data-pos="all">All</span>
                        <span class="filter-pill" data-pos="QB">QB</span>
                        <span class="filter-pill" data-pos="RB">RB</span>
                        <span class="filter-pill" data-pos="WR">WR</span>
                        <span class="filter-pill" data-pos="TE">TE</span>
                        <span class="filter-pill" data-pos="DST">DST</span>
                    </div>
                    <div class="search-input">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
                        </svg>
                        <input type="text" id="classicPlayerSearch" placeholder="Search players...">
                    </div>
                </div>
                <div class="table-container" id="classicPlayerPoolContainer">
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                        <h4>No Players Loaded</h4>
                        <p>Upload a CSV file to load player projections</p>
                    </div>
                </div>
            </div>

            <!-- Generated Lineups -->
            <div class="card" id="classicLineupsCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                        </svg>
                        Generated Lineups
                        <span class="section-slate-badge" id="classicLineupsSlateBadge"></span>
                    </div>
                    <div class="export-section">
                        <span style="font-size: 0.8rem; color: var(--text-muted);" id="classicLineupCountDisplay">0 lineups</span>
                        <button class="btn btn-secondary" id="classicClearLineupsBtn">
                            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                            </svg>
                            Clear
                        </button>
                        <button class="btn btn-secondary" id="classicExportBtn">
                            <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/>
                            </svg>
                            Export CSV
                        </button>
                    </div>
                </div>
                <div class="classic-lineup-output" id="classicLineupOutput">
                    <div class="classic-lineup-row header">
                        <div class="sortable" data-sort="rank">Rank</div>
                        <div>QB</div>
                        <div>RB</div>
                        <div>RB</div>
                        <div>WR</div>
                        <div>WR</div>
                        <div>WR</div>
                        <div>TE</div>
                        <div>FLEX</div>
                        <div>DST</div>
                        <div class="sortable" data-sort="salary">Salary</div>
                        <div class="sortable sort-desc" data-sort="score">Score</div>
                    </div>
                    <div id="classicLineupRows"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Player Data Tab Content -->
    <div class="tab-content" id="playerdataTab">
        <div class="container">
            <!-- Stats Row for Player Data -->
            <div class="stats-row">
                <div class="stat-card green">
                    <div class="stat-card-label">Total Records</div>
                    <div class="stat-card-value" id="pdTotalRecords">0</div>
                    <div class="stat-card-sub">Game logs loaded</div>
                </div>
                <div class="stat-card purple">
                    <div class="stat-card-label">Unique Players</div>
                    <div class="stat-card-value" id="pdUniquePlayers">0</div>
                    <div class="stat-card-sub">Across all positions</div>
                </div>
                <div class="stat-card cyan">
                    <div class="stat-card-label">Correlations</div>
                    <div class="stat-card-value" id="pdCorrelations">0</div>
                    <div class="stat-card-sub">Computed pairs</div>
                </div>
                <div class="stat-card amber">
                    <div class="stat-card-label">Teams</div>
                    <div class="stat-card-value" id="pdTeams">0</div>
                    <div class="stat-card-sub">NFL teams</div>
                </div>
                <div class="stat-card red">
                    <div class="stat-card-label">Status</div>
                    <div class="stat-card-value" id="pdStatus" style="font-size: 1rem;">Not Ready</div>
                    <div class="stat-card-sub">Upload all files</div>
                </div>
            </div>

            <!-- Upload Cards Grid -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                        Upload Player Game History Files
                    </div>
                    <button class="btn btn-primary" id="computeCorrelationsBtn" disabled>
                        <svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                        </svg>
                        Compute Correlations
                    </button>
                </div>
                <div class="card-body">
                    <div class="player-data-grid">
                        <!-- QB Upload -->
                        <div class="pd-upload-card" id="pdQBCard">
                            <div class="pd-upload-header">
                                <div class="pd-position-badge qb">QB</div>
                                <span>Quarterbacks</span>
                            </div>
                            <div class="pd-upload-zone" id="pdQBZone">
                                <input type="file" id="pdQBInput" accept=".csv" style="display: none;">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <span>Drop CSV or click</span>
                            </div>
                            <div class="pd-upload-status" id="pdQBStatus">
                                <span class="pd-status-text">No file loaded</span>
                            </div>
                        </div>

                        <!-- RB Upload -->
                        <div class="pd-upload-card" id="pdRBCard">
                            <div class="pd-upload-header">
                                <div class="pd-position-badge rb">RB</div>
                                <span>Running Backs</span>
                            </div>
                            <div class="pd-upload-zone" id="pdRBZone">
                                <input type="file" id="pdRBInput" accept=".csv" style="display: none;">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <span>Drop CSV or click</span>
                            </div>
                            <div class="pd-upload-status" id="pdRBStatus">
                                <span class="pd-status-text">No file loaded</span>
                            </div>
                        </div>

                        <!-- WR Upload -->
                        <div class="pd-upload-card" id="pdWRCard">
                            <div class="pd-upload-header">
                                <div class="pd-position-badge wr">WR</div>
                                <span>Wide Receivers</span>
                            </div>
                            <div class="pd-upload-zone" id="pdWRZone">
                                <input type="file" id="pdWRInput" accept=".csv" style="display: none;">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <span>Drop CSV or click</span>
                            </div>
                            <div class="pd-upload-status" id="pdWRStatus">
                                <span class="pd-status-text">No file loaded</span>
                            </div>
                        </div>

                        <!-- TE Upload -->
                        <div class="pd-upload-card" id="pdTECard">
                            <div class="pd-upload-header">
                                <div class="pd-position-badge te">TE</div>
                                <span>Tight Ends</span>
                            </div>
                            <div class="pd-upload-zone" id="pdTEZone">
                                <input type="file" id="pdTEInput" accept=".csv" style="display: none;">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <span>Drop CSV or click</span>
                            </div>
                            <div class="pd-upload-status" id="pdTEStatus">
                                <span class="pd-status-text">No file loaded</span>
                            </div>
                        </div>

                        <!-- DST Upload -->
                        <div class="pd-upload-card" id="pdDSTCard">
                            <div class="pd-upload-header">
                                <div class="pd-position-badge dst">DST</div>
                                <span>Defense/ST</span>
                            </div>
                            <div class="pd-upload-zone" id="pdDSTZone">
                                <input type="file" id="pdDSTInput" accept=".csv" style="display: none;">
                                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                                </svg>
                                <span>Drop CSV or click</span>
                            </div>
                            <div class="pd-upload-status" id="pdDSTStatus">
                                <span class="pd-status-text">No file loaded</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Correlation Results Card -->
            <div class="card" id="correlationResultsCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                        </svg>
                        Position-to-Position Correlations (League Average)
                    </div>
                </div>
                <div class="card-body">
                    <div class="position-matrix" id="positionMatrix">
                        <!-- Header Row -->
                        <div class="matrix-cell header"></div>
                        <div class="matrix-cell header">QB</div>
                        <div class="matrix-cell header">RB</div>
                        <div class="matrix-cell header">WR</div>
                        <div class="matrix-cell header">TE</div>
                        <div class="matrix-cell header">DST</div>
                        <!-- Filled by JS -->
                    </div>
                    <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 12px; text-align: center;">
                        🟢 Positive = Good to stack together | 🔴 Negative = Avoid pairing | Based on teammate game-by-game correlations
                    </p>
                </div>
            </div>

            <!-- Team Correlations Grid -->
            <div class="card team-cards-container" id="teamCardsContainer" style="display: none;">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"/>
                        </svg>
                        Team Correlation Stacks
                    </div>
                    <span style="font-size: 0.8rem; color: var(--text-muted);">Click a team for full details</span>
                </div>
                <div class="card-body">
                    <div class="team-cards-grid" id="teamCardsGrid">
                        <!-- Filled by JS -->
                    </div>
                </div>
            </div>

            <!-- Position Pair Deep Dive -->
            <div class="card" id="positionPairCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
                        </svg>
                        Position Pair Correlations
                    </div>
                </div>
                <div class="card-body">
                    <div class="position-pair-tabs" id="positionPairTabs">
                        <div class="position-pair-tab active" data-pair="QB-WR">QB + WR</div>
                        <div class="position-pair-tab" data-pair="QB-TE">QB + TE</div>
                        <div class="position-pair-tab" data-pair="QB-RB">QB + RB</div>
                        <div class="position-pair-tab" data-pair="WR-WR">WR + WR</div>
                        <div class="position-pair-tab" data-pair="RB-WR">RB + WR</div>
                        <div class="position-pair-tab" data-pair="RB-TE">RB + TE</div>
                        <div class="position-pair-tab" data-pair="TE-WR">TE + WR</div>
                    </div>
                    <div class="correlation-table" id="positionPairTable">
                        <!-- Filled by JS -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Detail Modal -->
    <div class="team-detail-overlay" id="teamDetailOverlay">
        <div class="team-detail-modal" id="teamDetailModal">
            <div class="team-detail-header" id="teamDetailHeader">
                <div class="team-detail-header-left">
                    <img class="team-logo" id="teamDetailLogo" src="" alt="">
                    <h2 id="teamDetailName">Team Name</h2>
                </div>
                <button class="team-detail-close" id="teamDetailClose">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="team-detail-body" id="teamDetailBody">
                <!-- Filled by JS -->
            </div>
        </div>
    </div>

    <script>
        // Global state
        let players = [];
        let lineups = [];
        let selectedLineupCount = 100;
        let selectedTimeSeconds = null; // null means use count mode
        let generationMode = 'count'; // 'count' or 'time'
        let currentSort = { column: 'points', direction: 'desc' };
        let playerPoolSort = { column: 'flexProjection', direction: 'desc' };
        let currentPage = 1;
        const lineupsPerPage = 100;
        let minSalary = 49000;
        let maxSalary = 50000;
        let projectionFloor = 90; // percentage
        let entries = []; // DraftKings contest entries
        const SALARY_CAP = 50000;
        
        // Multi-slate support
        let slates = {};
        let currentSlate = null;
        const slateTimeMap = {
            '12:00': 1, '12:30': 1,
            '1:00': 1, '1:30': 1,
            '2:00': 2, '2:30': 2,
            '3:00': 2, '3:30': 2,
            '4:00': 3, '4:30': 3,
            '5:00': 3, '5:30': 3,
            '6:00': 4, '6:30': 4,
            '7:00': 4, '7:30': 4,
            '8:00': 5, '8:30': 5,
            '9:00': 5, '9:30': 5,
            '10:00': 6, '10:30': 6,
            '11:00': 6, '11:30': 6
        };

        // DOM Elements
        const uploadZone = document.getElementById('uploadZone');
        const csvInput = document.getElementById('csvInput');
        const generateBtn = document.getElementById('generateBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const playerPoolContainer = document.getElementById('playerPoolContainer');
        const lineupsCard = document.getElementById('lineupsCard');
        const lineupOutput = document.getElementById('lineupOutput');
        const lineupRows = document.getElementById('lineupRows');

        // File Upload Handling
        uploadZone.addEventListener('click', () => csvInput.click());
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                handleFile(file);
            }
        });

        csvInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleFile(file);
            }
            // Reset input so same file can be selected again
            csvInput.value = '';
        });
        
        // Slate button click handlers
        document.querySelectorAll('.slate-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const slateNum = parseInt(btn.dataset.slate);
                selectSlate(slateNum);
            });
        });
        
        function selectSlate(slateNum) {
            if (!slates[slateNum]) {
                // No data for this slate
                return;
            }
            
            // Update current slate
            currentSlate = slateNum;
            
            // Load data from slate
            const slate = slates[slateNum];
            players = slate.players;
            entries = slate.entries;
            lineups = slate.lineups || [];
            
            // Update UI
            updateSlateButtons();
            updateSlateInfo();
            updateSectionBadges();
            
            // Update stats
            document.getElementById('playersLoaded').textContent = players.length;
            document.getElementById('playerCount').textContent = players.length;
            document.getElementById('entriesLoaded').textContent = entries.length;
            generateBtn.disabled = players.length === 0;
            
            // Render
            renderPlayerPool();
            if (entries.length > 0) {
                renderEntries(new Map());
            } else {
                document.getElementById('entriesCard').style.display = 'none';
            }
            
            // Update optimize button
            document.getElementById('optimizeBtn').disabled = lineups.length === 0;
            document.getElementById('exportEntriesBtn').disabled = true;
            document.getElementById('optimizeStatus').textContent = lineups.length > 0 ? `${lineups.length} lineups ready` : '';
            
            // Show lineups if we have them
            if (lineups.length > 0) {
                document.getElementById('lineupsCard').style.display = 'block';
                document.getElementById('lineupCountDisplay').textContent = `${lineups.length} lineups`;
                currentPage = 1;
                renderLineups();
            } else {
                document.getElementById('lineupsCard').style.display = 'none';
            }
        }
        
        function updateSectionBadges() {
            const slate = currentSlate ? slates[currentSlate] : null;
            const badgeText = slate ? `${currentSlate} - ${slate.teams || 'Slate ' + currentSlate}` : '';
            
            // Update player pool and entries badges
            ['playerPoolSlateBadge', 'entriesSlateBadge'].forEach(id => {
                const badge = document.getElementById(id);
                if (badge) {
                    badge.textContent = badgeText;
                    badge.classList.toggle('visible', currentSlate !== null);
                }
            });
            
            // Update lineups badge with count
            const lineupsBadge = document.getElementById('lineupsSlateBadge');
            if (lineupsBadge) {
                const lineupCount = slate ? (slate.lineups || []).length : 0;
                const lineupsText = lineupCount > 0 
                    ? `${currentSlate} - ${slate.teams || 'Slate ' + currentSlate} • ${lineupCount} lineups`
                    : badgeText;
                lineupsBadge.textContent = lineupsText;
                lineupsBadge.classList.toggle('visible', currentSlate !== null);
            }
        }
        
        function updateSlateButtons() {
            document.querySelectorAll('.slate-btn').forEach(btn => {
                const slateNum = parseInt(btn.dataset.slate);
                btn.classList.remove('active', 'loaded');
                
                if (slates[slateNum]) {
                    btn.classList.add('loaded');
                }
                if (slateNum === currentSlate) {
                    btn.classList.add('active');
                }
            });
        }
        
        function updateSlateInfo() {
            const infoEl = document.getElementById('currentSlateInfo');
            if (!currentSlate || !slates[currentSlate]) {
                infoEl.classList.remove('visible');
                return;
            }
            
            const slate = slates[currentSlate];
            infoEl.classList.add('visible');
            document.getElementById('slateBadge').textContent = currentSlate;
            document.getElementById('slateTeams').textContent = slate.teams || 'Unknown';
            document.getElementById('slateDateTime').textContent = slate.dateTime || '';
            document.getElementById('slatePlayerCount').textContent = slate.players.length;
            document.getElementById('slateEntryCount').textContent = slate.entries.length;
        }
        
        function detectSlateNumber(gameInfo) {
            if (!gameInfo) return 1;
            
            // Extract time from game info (e.g., "ATL@TB 11/25/2025 12:00PM ET")
            const timeMatch = gameInfo.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
            if (!timeMatch) return 1;
            
            let hour = parseInt(timeMatch[1]);
            const isPM = timeMatch[3].toUpperCase() === 'PM';
            
            if (isPM && hour !== 12) hour += 12;
            if (!isPM && hour === 12) hour = 0;
            
            // Map to slate number based on hour
            if (hour >= 11 && hour < 14) return 1;  // 11 AM - 2 PM -> Slate 1 (12:00)
            if (hour >= 14 && hour < 16) return 2;  // 2 PM - 4 PM -> Slate 2 (2:00)
            if (hour >= 16 && hour < 18) return 3;  // 4 PM - 6 PM -> Slate 3 (4:00)
            if (hour >= 18 && hour < 20) return 4;  // 6 PM - 8 PM -> Slate 4 (6:00)
            if (hour >= 20 && hour < 22) return 5;  // 8 PM - 10 PM -> Slate 5 (8:00)
            if (hour >= 22 || hour < 11) return 6;  // 10 PM+ -> Slate 6 (10:00)
            
            return 1;
        }
        
        function parseGameInfo(gameInfo) {
            if (!gameInfo) return { teams: '', date: '', time: '' };
            
            // Parse "ATL@TB 11/25/2025 12:00PM ET"
            const parts = gameInfo.match(/([A-Z]{2,3})@([A-Z]{2,3})\s+(\d{1,2}\/\d{1,2}\/\d{4})\s+(\d{1,2}:\d{2}\s*(AM|PM))/i);
            if (parts) {
                return {
                    teams: `${parts[1]} @ ${parts[2]}`,
                    date: parts[3],
                    time: parts[4],
                    dateTime: `${parts[3]} ${parts[4]} ET`
                };
            }
            return { teams: gameInfo, date: '', time: '', dateTime: '' };
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                parseCSV(e.target.result, file.name);
            };
            reader.readAsText(file);
        }

        function parseCSV(csvText, fileName = '') {
            const lines = csvText.trim().split('\n');
            
            // Parse all rows
            const allRows = lines.map(line => parseCSVLine(line));
            
            // Row 1 has entry headers
            const entryHeaders = allRows[0].map(h => h.trim().toLowerCase().replace(/['"]/g, ''));
            console.log('Entry Headers (row 1):', entryHeaders);
            
            players = [];
            entries = [];
            
            // Find entry columns in row 1
            const findEntryCol = (name) => entryHeaders.findIndex(h => h.includes(name));
            
            let entryIdColIndex = findEntryCol('entry id');
            let contestNameColIndex = findEntryCol('contest name');
            let contestIdColIndex = findEntryCol('contest id');
            let entryFeeColIndex = findEntryCol('entry fee');
            let cptColIndex = entryHeaders.indexOf('cpt');
            
            // Find all FLEX columns
            let flexColIndices = [];
            entryHeaders.forEach((h, i) => {
                if (h === 'flex') flexColIndices.push(i);
            });
            
            console.log('Entry columns:', { entryIdColIndex, contestNameColIndex, cptColIndex, flexCount: flexColIndices.length });
            
            // Track contests for summary
            const contestsMap = new Map();
            
            // Parse entries from rows 2+ (left side)
            for (let i = 1; i < allRows.length; i++) {
                const values = allRows[i];
                if (!values || values.length < 2) continue;
                
                const entryId = values[entryIdColIndex]?.trim();
                const contestName = values[contestNameColIndex]?.trim() || '';
                const contestId = values[contestIdColIndex]?.trim() || '';
                const entryFee = values[entryFeeColIndex]?.trim() || '';
                
                if (entryId && contestName && entryId.match(/^\d/)) {
                    const cptPlayer = values[cptColIndex]?.trim() || '';
                    const flexPlayers = flexColIndices.map(idx => values[idx]?.trim() || '');
                    
                    entries.push({
                        entryId,
                        contestName,
                        contestId,
                        entryFee,
                        cpt: cptPlayer,
                        flex: flexPlayers,
                        salary: 0,
                        projection: 0
                    });
                    
                    if (!contestsMap.has(contestId)) {
                        contestsMap.set(contestId, { name: contestName, fee: entryFee, count: 0 });
                    }
                    contestsMap.get(contestId).count++;
                }
            }
            
            console.log('Entries parsed:', entries.length);
            
            // Now find the player pool - it starts at row 8 (index 7) in columns L+
            // Look for "Position" header to find the player pool section
            let playerPoolHeaderRow = -1;
            let playerPoolStartCol = -1;
            
            for (let rowIdx = 0; rowIdx < Math.min(15, allRows.length); rowIdx++) {
                const row = allRows[rowIdx];
                for (let colIdx = 0; colIdx < row.length; colIdx++) {
                    const cell = (row[colIdx] || '').trim().toLowerCase();
                    if (cell === 'position') {
                        playerPoolHeaderRow = rowIdx;
                        playerPoolStartCol = colIdx;
                        console.log(`Found player pool at row ${rowIdx + 1}, column ${colIdx + 1}`);
                        break;
                    }
                }
                if (playerPoolHeaderRow !== -1) break;
            }
            
            if (playerPoolHeaderRow === -1) {
                console.log('No player pool found, trying old format...');
                parseCSVOldFormat(lines, entryHeaders);
                return;
            }
            
            // Get player pool headers
            const poolHeaders = allRows[playerPoolHeaderRow].slice(playerPoolStartCol).map(h => 
                (h || '').trim().toLowerCase().replace(/['"]/g, '')
            );
            console.log('Player pool headers:', poolHeaders);
            
            // Find column indices within player pool
            const findPoolCol = (...names) => {
                for (const name of names) {
                    const idx = poolHeaders.findIndex(h => h.includes(name));
                    if (idx !== -1) return idx;
                }
                return -1;
            };
            
            const posCol = findPoolCol('position');
            const nameIdCol = findPoolCol('name + id', 'name+id');
            const nameCol = poolHeaders.findIndex((h, i) => h === 'name' && i !== nameIdCol);
            const idCol = poolHeaders.findIndex(h => h === 'id');
            const rosterPosCol = findPoolCol('roster pos', 'roster position');
            const salaryCol = findPoolCol('salary');
            const gameInfoCol = findPoolCol('game info', 'gameinfo');
            const teamCol = findPoolCol('teamabbrev', 'team');
            const avgPointsCol = findPoolCol('avgpointspergame', 'avg points', 'avgpoints');
            
            console.log('Player pool column indices:', { posCol, nameCol, nameIdCol, idCol, rosterPosCol, salaryCol, teamCol, avgPointsCol });
            
            // Parse player pool starting from row after headers
            for (let rowIdx = playerPoolHeaderRow + 1; rowIdx < allRows.length; rowIdx++) {
                const row = allRows[rowIdx];
                const poolRow = row.slice(playerPoolStartCol);
                
                if (poolRow.length < 3) continue;
                
                const position = (poolRow[posCol] || '').trim().toUpperCase();
                const name = (poolRow[nameCol] || '').trim();
                const nameId = (poolRow[nameIdCol] || '').trim();
                const playerId = (poolRow[idCol] || '').trim();
                const rosterPos = (poolRow[rosterPosCol] || '').trim().toUpperCase();
                const salary = parseInt((poolRow[salaryCol] || '0').toString().replace(/[,$]/g, '')) || 0;
                const gameInfo = (poolRow[gameInfoCol] || '').trim();
                const team = (poolRow[teamCol] || '').trim();
                const avgPoints = parseFloat(poolRow[avgPointsCol] || '0') || 0;
                
                if (name && salary > 0 && position) {
                    const isCaptain = rosterPos.includes('CPT');
                    
                    players.push({
                        id: playerId || rowIdx,
                        name,
                        nameId,
                        position: position.replace('CPT', '').trim(),
                        salary,
                        projection: avgPoints,
                        team,
                        game: gameInfo,
                        rosterPosition: rosterPos,
                        isCaptain,
                        value: avgPoints > 0 && salary > 0 ? avgPoints / (salary / 1000) : 0
                    });
                }
            }
            
            console.log('Raw players parsed:', players.length);
            
            if (players.length === 0) {
                console.log('No players found, trying old format...');
                parseCSVOldFormat(lines, entryHeaders);
                return;
            }

            // Group players by name to get FLEX and CPT versions
            const playerMap = new Map();
            players.forEach(p => {
                const key = p.name + '_' + p.team;
                if (!playerMap.has(key)) {
                    playerMap.set(key, {
                        id: p.id,
                        name: p.name,
                        nameId: p.nameId,
                        position: p.position,
                        team: p.team,
                        game: p.game,
                        flexSalary: 0,
                        flexProjection: 0,
                        cptSalary: 0,
                        cptProjection: 0
                    });
                }
                const entry = playerMap.get(key);
                if (p.isCaptain) {
                    entry.cptSalary = p.salary;
                    entry.cptProjection = p.projection;
                    entry.cptNameId = p.nameId;
                } else {
                    entry.flexSalary = p.salary;
                    entry.flexProjection = p.projection;
                    entry.flexNameId = p.nameId;
                }
            });

            // Convert to unified player list
            players = Array.from(playerMap.values()).map((p, idx) => {
                if (p.cptSalary === 0 && p.flexSalary > 0) {
                    p.cptSalary = Math.round(p.flexSalary * 1.5);
                    p.cptProjection = p.flexProjection * 1.5;
                }
                if (p.flexSalary === 0 && p.cptSalary > 0) {
                    p.flexSalary = Math.round(p.cptSalary / 1.5);
                    p.flexProjection = p.cptProjection / 1.5;
                }
                
                return {
                    id: p.id || idx,
                    name: p.name,
                    nameId: p.nameId,
                    flexNameId: p.flexNameId,
                    cptNameId: p.cptNameId,
                    position: p.position,
                    team: p.team,
                    game: p.game,
                    flexSalary: p.flexSalary,
                    flexProjection: p.flexProjection,
                    cptSalary: p.cptSalary,
                    cptProjection: p.cptProjection,
                    value: p.flexProjection > 0 && p.flexSalary > 0 ? p.flexProjection / (p.flexSalary / 1000) : 0
                };
            }).filter(p => p.flexSalary > 0);
            
            console.log('Final players after grouping:', players.length);

            // Calculate entry salaries and projections
            entries.forEach(entry => {
                let totalSalary = 0;
                let totalProjection = 0;
                
                const cptName = extractPlayerName(entry.cpt);
                const cptPlayer = players.find(p => p.name === cptName || entry.cpt.includes(p.name));
                if (cptPlayer) {
                    totalSalary += cptPlayer.cptSalary;
                    totalProjection += cptPlayer.cptProjection;
                }
                
                entry.flex.forEach(flexStr => {
                    const flexName = extractPlayerName(flexStr);
                    const flexPlayer = players.find(p => p.name === flexName || flexStr.includes(p.name));
                    if (flexPlayer) {
                        totalSalary += flexPlayer.flexSalary;
                        totalProjection += flexPlayer.flexProjection;
                    }
                });
                
                entry.salary = totalSalary;
                entry.projection = totalProjection;
            });

            // Detect slate number from game info
            let gameInfo = '';
            if (players.length > 0 && players[0].game) {
                gameInfo = players[0].game;
            }
            const slateNum = detectSlateNumber(gameInfo);
            const parsedInfo = parseGameInfo(gameInfo);
            
            // Store in slates object
            slates[slateNum] = {
                players: [...players],
                entries: [...entries],
                lineups: [],
                teams: parsedInfo.teams,
                date: parsedInfo.date,
                time: parsedInfo.time,
                dateTime: parsedInfo.dateTime,
                fileName: fileName
            };
            
            // Auto-select this slate
            currentSlate = slateNum;
            
            // Update UI
            updateSlateButtons();
            updateSlateInfo();
            updateSectionBadges();
            
            document.getElementById('playersLoaded').textContent = players.length;
            document.getElementById('playerCount').textContent = players.length;
            document.getElementById('entriesLoaded').textContent = entries.length;
            generateBtn.disabled = players.length === 0;
            
            // Update file status
            document.getElementById('fileStatus').textContent = `Slate ${slateNum} - ${parsedInfo.teams || fileName}`;
            
            if (entries.length > 0) {
                renderEntries(contestsMap);
            }
            
            renderPlayerPool();
            
            console.log(`Loaded slate ${slateNum}: ${players.length} players, ${entries.length} entries`);
        }
        
        // Old format parser for backwards compatibility
        function parseCSVOldFormat(lines, headers) {
            players = [];
            
            for (let i = 1; i < lines.length; i++) {
                const values = parseCSVLine(lines[i]);
                if (values.length < headers.length) continue;

                const player = {};
                headers.forEach((header, index) => {
                    player[header] = values[index]?.trim().replace(/['"]/g, '') || '';
                });

                const name = player.name || player.player || player.nickname || '';
                const position = (player.position || player.pos || player['roster position'] || '').toUpperCase();
                const salary = parseInt(player.salary || player.sal || 0);
                const projection = parseFloat(player['avgpointspergame'] || player.avgpointspergame || player.fpts || player.projection || player.points || player.proj || 0);
                const team = player.team || player.teamabbrev || player['team abbrev'] || '';
                const game = player.game || player['game info'] || '';

                if (name && salary > 0) {
                    const isCaptain = position.includes('CPT') || (player['roster position'] || '').includes('CPT');
                    
                    players.push({
                        id: i,
                        name: name,
                        position: position.replace('CPT', '').trim() || extractPosition(position),
                        salary: salary,
                        projection: projection,
                        team: team,
                        game: game,
                        isCaptain: isCaptain,
                        value: projection / (salary / 1000)
                    });
                }
            }

            const playerMap = new Map();
            players.forEach(p => {
                const key = p.name + '_' + p.team;
                if (!playerMap.has(key)) {
                    playerMap.set(key, {
                        name: p.name,
                        position: p.position,
                        team: p.team,
                        game: p.game,
                        flexSalary: 0,
                        flexProjection: 0,
                        cptSalary: 0,
                        cptProjection: 0
                    });
                }
                const entry = playerMap.get(key);
                if (p.isCaptain) {
                    entry.cptSalary = p.salary;
                    entry.cptProjection = p.projection;
                } else {
                    entry.flexSalary = p.salary;
                    entry.flexProjection = p.projection;
                }
            });

            players = Array.from(playerMap.values()).map((p, idx) => {
                if (p.cptSalary === 0 && p.flexSalary > 0) {
                    p.cptSalary = Math.round(p.flexSalary * 1.5);
                    p.cptProjection = p.flexProjection * 1.5;
                }
                if (p.flexSalary === 0 && p.cptSalary > 0) {
                    p.flexSalary = Math.round(p.cptSalary / 1.5);
                    p.flexProjection = p.cptProjection / 1.5;
                }
                
                return {
                    id: idx,
                    name: p.name,
                    position: p.position,
                    team: p.team,
                    game: p.game,
                    flexSalary: p.flexSalary,
                    flexProjection: p.flexProjection,
                    cptSalary: p.cptSalary,
                    cptProjection: p.cptProjection,
                    value: p.flexProjection / (p.flexSalary / 1000)
                };
            }).filter(p => p.flexSalary > 0);

            // Detect slate number from game info
            let gameInfo = '';
            if (players.length > 0 && players[0].game) {
                gameInfo = players[0].game;
            }
            const slateNum = detectSlateNumber(gameInfo);
            const parsedInfo = parseGameInfo(gameInfo);
            
            // Store in slates object
            slates[slateNum] = {
                players: [...players],
                entries: [],
                lineups: [],
                teams: parsedInfo.teams,
                date: parsedInfo.date,
                time: parsedInfo.time,
                dateTime: parsedInfo.dateTime,
                fileName: ''
            };
            
            // Auto-select this slate
            currentSlate = slateNum;
            
            // Update UI
            updateSlateButtons();
            updateSlateInfo();
            updateSectionBadges();

            document.getElementById('playersLoaded').textContent = players.length;
            document.getElementById('playerCount').textContent = players.length;
            generateBtn.disabled = players.length === 0;
            
            document.getElementById('fileStatus').textContent = `Slate ${slateNum} - ${parsedInfo.teams || 'Loaded'}`;
            
            renderPlayerPool();
        }
        
        // Extract player name from DK format (e.g., "Drake Lon" from entry)
        function extractPlayerName(str) {
            if (!str) return '';
            // Remove ID in parentheses if present
            return str.replace(/\s*\(\d+\)\s*$/, '').trim();
        }
        
        // Render entries section
        // Check if a contest is a cash game (Double Up, H2H, vs, etc.)
        function isCashGame(contestName) {
            const lowerName = contestName.toLowerCase();
            return lowerName.includes('double') || 
                   lowerName.includes(' vs') || 
                   lowerName.includes(' vs.') ||
                   lowerName.includes('roobk19');
        }

        function renderEntries(contestsMap) {
            const entriesCard = document.getElementById('entriesCard');
            const container = document.getElementById('entriesGroupedContainer');
            const optimizeCard = document.getElementById('optimizeCard');
            
            entriesCard.style.display = 'block';
            
            // Show optimize card if we have entries
            if (entries.length > 0) {
                optimizeCard.style.display = 'block';
                // Enable optimize button if we have lineups
                document.getElementById('optimizeBtn').disabled = lineups.length === 0;
            }
            
            // Update stats card
            document.getElementById('entriesLoaded').textContent = entries.length;
            
            // Update summary
            document.getElementById('entriesCount').textContent = `${entries.length} entries`;
            const totalFees = entries.reduce((sum, e) => {
                const fee = parseFloat(e.entryFee.replace('$', '')) || 0;
                return sum + fee;
            }, 0);
            document.getElementById('totalEntryFees').textContent = `$${totalFees.toFixed(2)} total`;
            
            // Group entries by contest and calculate totals
            const contestGroups = new Map();
            entries.forEach(entry => {
                if (!contestGroups.has(entry.contestId)) {
                    contestGroups.set(entry.contestId, {
                        name: entry.contestName,
                        fee: entry.entryFee,
                        entries: [],
                        totalFees: 0
                    });
                }
                const group = contestGroups.get(entry.contestId);
                group.entries.push(entry);
                group.totalFees += parseFloat(entry.entryFee.replace('$', '')) || 0;
            });
            
            // Sort: GPPs first (by total fees desc), then Cash games (by total fees desc)
            const sortedGroups = Array.from(contestGroups.entries())
                .sort((a, b) => {
                    const aIsCash = isCashGame(a[1].name);
                    const bIsCash = isCashGame(b[1].name);
                    
                    // GPPs come before Cash
                    if (aIsCash !== bIsCash) {
                        return aIsCash ? 1 : -1;
                    }
                    // Within same type, sort by total fees (highest first)
                    return b[1].totalFees - a[1].totalFees;
                });
            
            // Clean contest name - remove game info like "(ATL @ TB)"
            const cleanContestName = (name) => {
                return name.replace(/\s*\([A-Z]{2,3}\s*@\s*[A-Z]{2,3}\)\s*$/i, '').trim();
            };
            
            // Render grouped entries
            container.innerHTML = sortedGroups.map(([contestId, group]) => {
                const contestName = cleanContestName(group.name);
                const entryFee = group.fee;
                const numEntries = group.entries.length;
                const totalContestFees = group.totalFees.toFixed(2);
                const isCash = isCashGame(group.name);
                const gameTypeBadge = isCash 
                    ? '<span class="game-type-badge cash">CASH</span>' 
                    : '<span class="game-type-badge gpp">GPP</span>';
                
                // Build table rows for this contest's entries
                const tableRows = group.entries.map((entry, idx) => {
                    const cptName = extractPlayerName(entry.cpt);
                    const cptPlayer = players.find(p => p.name === cptName || entry.cpt.includes(p.name));
                    
                    const flexCells = entry.flex.map(flexStr => {
                        const flexName = extractPlayerName(flexStr);
                        const flexPlayer = players.find(p => p.name === flexName || flexStr.includes(p.name));
                        const displayName = flexPlayer ? flexPlayer.name : extractPlayerName(flexStr);
                        const pos = flexPlayer ? flexPlayer.position : '';
                        return `<td><span class="entry-player">${displayName || '-'}</span>${pos ? `<span class="entry-pos">${pos}</span>` : ''}</td>`;
                    }).join('');
                    
                    const cptDisplayName = cptPlayer ? cptPlayer.name : extractPlayerName(entry.cpt);
                    const cptPos = cptPlayer ? cptPlayer.position : '';
                    
                    return `
                        <tr>
                            <td class="entry-fee-cell">${entry.entryFee}</td>
                            <td><span class="entry-player cpt">${cptDisplayName}</span>${cptPos ? `<span class="entry-pos">${cptPos}</span>` : ''}</td>
                            ${flexCells}
                            <td class="entry-salary-cell">$${entry.salary.toLocaleString()}</td>
                            <td class="entry-proj-cell">${entry.projection.toFixed(1)}</td>
                        </tr>
                    `;
                }).join('');
                
                return `
                    <div class="contest-group ${isCash ? 'cash-game' : 'gpp-game'}">
                        <div class="contest-group-header">
                            <div class="contest-group-left">
                                <span class="contest-group-name">${contestName}</span>
                                ${gameTypeBadge}
                            </div>
                            <div class="contest-group-stats">
                                <span>${numEntries} ${numEntries === 1 ? 'entry' : 'entries'}</span>
                                <span class="dot">•</span>
                                <span>${entryFee}/ea</span>
                                <span class="dot">•</span>
                                <span class="contest-group-fee">$${totalContestFees}</span>
                            </div>
                        </div>
                        <table class="contest-entries-table">
                            <thead>
                                <tr>
                                    <th style="width: 55px;">Fee</th>
                                    <th style="width: 130px;">Captain</th>
                                    <th>Flex 1</th>
                                    <th>Flex 2</th>
                                    <th>Flex 3</th>
                                    <th>Flex 4</th>
                                    <th>Flex 5</th>
                                    <th style="width: 75px; text-align: right;">Salary</th>
                                    <th style="width: 60px; text-align: right;">Proj</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows}
                            </tbody>
                        </table>
                    </div>
                `;
            }).join('');
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            return result;
        }

        function extractPosition(pos) {
            const positions = ['QB', 'RB', 'WR', 'TE', 'K', 'DST', 'DEF'];
            for (const p of positions) {
                if (pos.toUpperCase().includes(p)) return p;
            }
            return pos;
        }

        // Render Player Pool
        function renderPlayerPool(filter = 'all', search = '') {
            if (players.length === 0) {
                playerPoolContainer.innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                        <h4>No Players Loaded</h4>
                        <p>Upload a CSV file to load player projections</p>
                    </div>
                `;
                return;
            }

            let filteredPlayers = [...players];
            
            if (filter !== 'all') {
                filteredPlayers = filteredPlayers.filter(p => 
                    p.position.toUpperCase() === filter.toUpperCase() ||
                    (filter === 'DST' && (p.position === 'DEF' || p.position === 'DST'))
                );
            }

            if (search) {
                const searchLower = search.toLowerCase();
                filteredPlayers = filteredPlayers.filter(p => 
                    p.name.toLowerCase().includes(searchLower) ||
                    p.team.toLowerCase().includes(searchLower)
                );
            }

            // Sort by current sort column
            filteredPlayers.sort((a, b) => {
                let aVal, bVal;
                if (playerPoolSort.column === 'cptProjection') {
                    aVal = a.flexProjection * 1.5;
                    bVal = b.flexProjection * 1.5;
                } else if (playerPoolSort.column === 'cptSalary') {
                    aVal = a.flexSalary * 1.5;
                    bVal = b.flexSalary * 1.5;
                } else {
                    aVal = a[playerPoolSort.column];
                    bVal = b[playerPoolSort.column];
                }
                return playerPoolSort.direction === 'desc' ? bVal - aVal : aVal - bVal;
            });

            document.getElementById('playerCount').textContent = filteredPlayers.length;

            // Determine sort classes for headers
            const getSortClass = (col) => {
                if (playerPoolSort.column === col) {
                    return playerPoolSort.direction === 'desc' ? 'sortable sort-desc' : 'sortable sort-asc';
                }
                return 'sortable';
            };

            playerPoolContainer.innerHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Player</th>
                            <th>Pos</th>
                            <th>Team</th>
                            <th class="${getSortClass('flexSalary')}" data-sort="flexSalary">FLEX Salary</th>
                            <th class="${getSortClass('cptSalary')}" data-sort="cptSalary">CPT Salary</th>
                            <th class="${getSortClass('flexProjection')}" data-sort="flexProjection">FLEX Proj</th>
                            <th class="${getSortClass('cptProjection')}" data-sort="cptProjection">CPT Proj</th>
                            <th class="${getSortClass('value')}" data-sort="value">Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${filteredPlayers.map(p => `
                            <tr>
                                <td style="font-weight: 500;">${p.name}</td>
                                <td><span class="position-badge ${p.position.toLowerCase()}">${p.position}</span></td>
                                <td class="team-badge">${p.team}</td>
                                <td>$${p.flexSalary.toLocaleString()}</td>
                                <td>$${Math.round(p.flexSalary * 1.5).toLocaleString()}</td>
                                <td style="color: var(--accent-primary); font-weight: 600;">${p.flexProjection.toFixed(2)}</td>
                                <td style="color: var(--accent-tertiary); font-weight: 600;">${(p.flexProjection * 1.5).toFixed(2)}</td>
                                <td>${p.value.toFixed(2)}</td>
                            </tr>
                        `).join('')}
                    </tbody>
                </table>
            `;
        }

        // Position Filter
        document.getElementById('positionFilters').addEventListener('click', (e) => {
            if (e.target.classList.contains('filter-pill')) {
                document.querySelectorAll('#positionFilters .filter-pill').forEach(p => p.classList.remove('active'));
                e.target.classList.add('active');
                renderPlayerPool(e.target.dataset.pos, document.getElementById('playerSearch').value);
            }
        });

        // Search
        document.getElementById('playerSearch').addEventListener('input', (e) => {
            const activeFilter = document.querySelector('#positionFilters .filter-pill.active').dataset.pos;
            renderPlayerPool(activeFilter, e.target.value);
        });

        // Player Pool Sortable Columns
        playerPoolContainer.addEventListener('click', (e) => {
            const sortable = e.target.closest('.sortable');
            if (!sortable) return;

            const column = sortable.dataset.sort;
            
            // Toggle direction
            if (playerPoolSort.column === column) {
                playerPoolSort.direction = playerPoolSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                playerPoolSort.column = column;
                playerPoolSort.direction = 'desc';
            }

            const activeFilter = document.querySelector('#positionFilters .filter-pill.active').dataset.pos;
            renderPlayerPool(activeFilter, document.getElementById('playerSearch').value);
        });

        // Lineup Count Selection
        document.querySelectorAll('.lineup-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lineup-count-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.lineup-time-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedLineupCount = parseInt(btn.dataset.count);
                selectedTimeSeconds = null;
                generationMode = 'count';
            });
        });

        // Lineup Time Selection
        document.querySelectorAll('.lineup-time-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.lineup-time-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.lineup-count-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedTimeSeconds = parseInt(btn.dataset.seconds);
                selectedLineupCount = null;
                generationMode = 'time';
            });
        });

        // Salary Range Sliders
        const minSalarySlider = document.getElementById('minSalarySlider');
        const maxSalarySlider = document.getElementById('maxSalarySlider');
        const minSalaryValue = document.getElementById('minSalaryValue');
        const maxSalaryValue = document.getElementById('maxSalaryValue');
        const salaryRange = document.getElementById('salaryRange');

        function updateSalaryRange() {
            const minVal = parseInt(minSalarySlider.value);
            const maxVal = parseInt(maxSalarySlider.value);
            
            // Prevent overlap
            if (minVal > maxVal - 100) {
                if (this === minSalarySlider) {
                    minSalarySlider.value = maxVal - 100;
                } else {
                    maxSalarySlider.value = minVal + 100;
                }
            }
            
            minSalary = parseInt(minSalarySlider.value);
            maxSalary = parseInt(maxSalarySlider.value);
            
            minSalaryValue.textContent = minSalary.toLocaleString();
            maxSalaryValue.textContent = maxSalary.toLocaleString();
            
            // Update range highlight
            const minPercent = ((minSalary - 40000) / 10000) * 100;
            const maxPercent = ((maxSalary - 40000) / 10000) * 100;
            salaryRange.style.left = minPercent + '%';
            salaryRange.style.width = (maxPercent - minPercent) + '%';
        }

        minSalarySlider.addEventListener('input', updateSalaryRange);
        maxSalarySlider.addEventListener('input', updateSalaryRange);
        updateSalaryRange(); // Initialize

        // Projection Floor Slider
        const projFloorSlider = document.getElementById('projFloorSlider');
        const projFloorValue = document.getElementById('projFloorValue');

        function updateProjFloor() {
            projectionFloor = parseFloat(projFloorSlider.value);
            projFloorValue.textContent = projectionFloor.toFixed(1) + '%';
            
            // Update slider background gradient
            const percent = ((projectionFloor - 80) / 20) * 100;
            projFloorSlider.style.background = `linear-gradient(to right, var(--accent-tertiary) ${percent}%, var(--bg-input) ${percent}%)`;
        }

        projFloorSlider.addEventListener('input', updateProjFloor);
        updateProjFloor(); // Initialize

        // Generate Lineups
        generateBtn.addEventListener('click', generateLineups);
        
        // Optimization Mode Selection
        let optimizeMode = 'balanced';
        let diversityStrength = 5;
        const pawPatrolSettings = document.getElementById('pawPatrolSettings');
        const diversitySlider = document.getElementById('diversitySlider');
        const diversityValue = document.getElementById('diversityValue');
        const portfolioSummary = document.getElementById('portfolioSummary');
        const portfolioExposureList = document.getElementById('portfolioExposureList');
        
        document.querySelectorAll('.optimize-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.optimize-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                optimizeMode = btn.dataset.mode;
                
                // Show/hide Paw Patrol settings
                if (optimizeMode === 'paw-patrol') {
                    pawPatrolSettings.style.display = 'block';
                } else {
                    pawPatrolSettings.style.display = 'none';
                    portfolioSummary.style.display = 'none';
                }
            });
        });
        
        // Diversity slider - real-time updates
        diversitySlider.addEventListener('input', () => {
            diversityStrength = parseInt(diversitySlider.value);
            diversityValue.textContent = diversityStrength;
            
            // If we have already optimized entries with Paw Patrol, re-optimize in real-time
            if (optimizeMode === 'paw-patrol' && entries.length > 0 && lineups.length > 0) {
                const hasOptimizedEntries = entries.some(e => e.optimizedLineup);
                if (hasOptimizedEntries) {
                    optimizeEntriesPawPatrol();
                }
            }
        });
        
        // Optimize Entries Button
        const optimizeBtn = document.getElementById('optimizeBtn');
        const optimizeCard = document.getElementById('optimizeCard');
        const optimizeStatus = document.getElementById('optimizeStatus');
        
        optimizeBtn.addEventListener('click', optimizeEntries);
        
        function optimizeEntries() {
            if (lineups.length === 0) {
                alert('Please generate lineups first!');
                return;
            }
            
            if (entries.length === 0) {
                alert('No entries to optimize!');
                return;
            }
            
            const minUniques = parseInt(document.getElementById('minUniques').value) || 1;
            
            // Sort lineups by projection (highest first)
            const sortedLineups = [...lineups].sort((a, b) => b.totalProjection - a.totalProjection);
            
            // The top lineup for cash games
            const topLineup = sortedLineups[0];
            
            // Track which lineups have been used for GPP
            let gppLineupIndex = 0;
            const usedLineups = new Set();
            
            // Separate entries into cash and GPP
            const cashEntries = [];
            const gppEntries = [];
            
            entries.forEach(entry => {
                if (optimizeMode === 'cash' || isCashGame(entry.contestName)) {
                    cashEntries.push(entry);
                } else {
                    gppEntries.push(entry);
                }
            });
            
            // Assign top lineup to all cash entries
            cashEntries.forEach(entry => {
                assignLineupToEntry(entry, topLineup);
            });
            
            // Assign unique lineups to GPP entries
            if (optimizeMode === 'paw-patrol') {
                // Paw Patrol mode - portfolio optimization
                optimizeEntriesPawPatrol();
                return; // Paw Patrol handles everything including status update
            } else {
                // Balanced mode - each GPP entry gets a unique lineup
                gppEntries.forEach(entry => {
                    // Find the next unused lineup
                    while (gppLineupIndex < sortedLineups.length && usedLineups.has(gppLineupIndex)) {
                        gppLineupIndex++;
                    }
                    
                    if (gppLineupIndex < sortedLineups.length) {
                        assignLineupToEntry(entry, sortedLineups[gppLineupIndex]);
                        usedLineups.add(gppLineupIndex);
                        gppLineupIndex++;
                    } else {
                        // Ran out of unique lineups, cycle back
                        assignLineupToEntry(entry, sortedLineups[gppLineupIndex % sortedLineups.length]);
                        gppLineupIndex++;
                    }
                });
            }
            
            // Update status
            const cashCount = cashEntries.length;
            const gppCount = gppEntries.length;
            optimizeStatus.textContent = `✓ Optimized! ${cashCount} cash (top lineup), ${gppCount} GPP (unique)`;
            optimizeStatus.className = 'optimize-status success';
            
            // Enable export button
            document.getElementById('exportEntriesBtn').disabled = false;
            
            // Save updated entries to current slate
            if (currentSlate && slates[currentSlate]) {
                slates[currentSlate].entries = [...entries];
            }
            
            // Re-render entries
            renderEntries(new Map());
        }
        
        // Paw Patrol Portfolio Optimization Algorithm
        function optimizeEntriesPawPatrol() {
            const sortedLineups = [...lineups].sort((a, b) => b.totalProjection - a.totalProjection);
            const topLineup = sortedLineups[0];
            const maxProjection = topLineup.totalProjection;
            
            // Separate entries into cash and GPP
            const cashEntries = [];
            const gppEntries = [];
            
            entries.forEach(entry => {
                if (isCashGame(entry.contestName)) {
                    cashEntries.push(entry);
                } else {
                    gppEntries.push(entry);
                }
            });
            
            // Assign top lineup to all cash entries
            cashEntries.forEach(entry => {
                assignLineupToEntry(entry, topLineup);
            });
            
            // Sort GPP entries by entry fee (highest first) - big money gets best picks
            gppEntries.sort((a, b) => {
                const feeA = parseFloat(a.entryFee.replace(/[$,]/g, '')) || 0;
                const feeB = parseFloat(b.entryFee.replace(/[$,]/g, '')) || 0;
                return feeB - feeA;
            });
            
            // Calculate total GPP fees for exposure percentages
            const totalGppFees = gppEntries.reduce((sum, e) => {
                return sum + (parseFloat(e.entryFee.replace(/[$,]/g, '')) || 0);
            }, 0);
            
            // Build candidate pool from top lineups
            // Use top 200 or all lineups if fewer available
            const poolSize = Math.min(200, sortedLineups.length);
            const candidatePool = sortedLineups.slice(0, poolSize);
            
            // Analyze the pool to find "chalk" (most common players/stacks)
            const poolAnalysis = analyzeLineupPool(candidatePool);
            
            // Portfolio tracking
            const portfolio = {
                playerExposure: new Map(), // player name -> total $ exposure
                captainExposure: new Map(), // captain name -> total $ exposure  
                stackExposure: new Map(), // team stack -> total $ exposure
                assignedLineups: [] // lineups already assigned
            };
            
            // Assign lineups to GPP entries using portfolio optimization
            gppEntries.forEach(entry => {
                const entryFee = parseFloat(entry.entryFee.replace(/[$,]/g, '')) || 0.01;
                
                // Score each candidate lineup
                let bestLineup = null;
                let bestScore = -Infinity;
                
                candidatePool.forEach(lineup => {
                    const score = scoreLineupForPortfolio(
                        lineup, 
                        portfolio, 
                        maxProjection, 
                        totalGppFees,
                        poolAnalysis,
                        diversityStrength
                    );
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestLineup = lineup;
                    }
                });
                
                if (bestLineup) {
                    assignLineupToEntry(entry, bestLineup);
                    
                    // Update portfolio exposure
                    updatePortfolioExposure(portfolio, bestLineup, entryFee);
                }
            });
            
            // Update status with portfolio info
            const cashCount = cashEntries.length;
            const gppCount = gppEntries.length;
            optimizeStatus.textContent = `✓ Portfolio optimized! ${cashCount} cash, ${gppCount} GPP (diversity: ${diversityStrength})`;
            optimizeStatus.className = 'optimize-status success';
            
            // Show portfolio exposure summary
            displayPortfolioSummary(portfolio, totalGppFees);
            
            // Enable export button
            document.getElementById('exportEntriesBtn').disabled = false;
            
            // Save updated entries to current slate
            if (currentSlate && slates[currentSlate]) {
                slates[currentSlate].entries = [...entries];
            }
            
            // Re-render entries
            renderEntries(new Map());
        }
        
        // Analyze lineup pool to find "chalk" builds
        function analyzeLineupPool(pool) {
            const playerCounts = new Map();
            const captainCounts = new Map();
            const stackCounts = new Map();
            
            pool.forEach(lineup => {
                // Count players
                lineup.players.forEach(player => {
                    const count = playerCounts.get(player.name) || 0;
                    playerCounts.set(player.name, count + 1);
                    
                    // Count captains separately
                    if (player.isCpt) {
                        const cptCount = captainCounts.get(player.name) || 0;
                        captainCounts.set(player.name, cptCount + 1);
                    }
                });
                
                // Count primary stack (team with most players)
                const teamCounts = new Map();
                lineup.players.forEach(player => {
                    const tc = teamCounts.get(player.team) || 0;
                    teamCounts.set(player.team, tc + 1);
                });
                
                let primaryStack = '';
                let maxCount = 0;
                teamCounts.forEach((count, team) => {
                    if (count > maxCount) {
                        maxCount = count;
                        primaryStack = `${team} ${count}`;
                    }
                });
                
                if (primaryStack) {
                    const sc = stackCounts.get(primaryStack) || 0;
                    stackCounts.set(primaryStack, sc + 1);
                }
            });
            
            return { playerCounts, captainCounts, stackCounts, poolSize: pool.length };
        }
        
        // Score a lineup for portfolio selection
        function scoreLineupForPortfolio(lineup, portfolio, maxProjection, totalGppFees, poolAnalysis, diversity) {
            const diversityFactor = diversity / 10; // 0 to 1
            
            // 1. Projection Score (0.90 to 1.00 for top lineups)
            const projectionScore = lineup.totalProjection / maxProjection;
            
            // 2. Portfolio Correlation Score (how correlated is this with what we already have)
            let correlationScore = 0;
            if (totalGppFees > 0) {
                lineup.players.forEach(player => {
                    const exposure = portfolio.playerExposure.get(player.name) || 0;
                    const exposurePct = exposure / totalGppFees;
                    
                    // Captain correlation weighted 2x
                    if (player.isCpt) {
                        correlationScore += exposurePct * 2;
                    } else {
                        correlationScore += exposurePct;
                    }
                });
                correlationScore /= 8; // Normalize (6 players, captain weighted 2x = 8 max)
            }
            
            // 3. Pool Uniqueness Score (how different from "chalk")
            let uniquenessScore = 0;
            const captain = lineup.players.find(p => p.isCpt);
            
            if (captain && poolAnalysis.captainCounts.size > 0) {
                const cptFrequency = (poolAnalysis.captainCounts.get(captain.name) || 0) / poolAnalysis.poolSize;
                // Bonus for less common captains (but still quality - they're in the pool)
                uniquenessScore += (1 - cptFrequency) * 0.15;
            }
            
            // Primary stack uniqueness
            const teamCounts = new Map();
            lineup.players.forEach(player => {
                const tc = teamCounts.get(player.team) || 0;
                teamCounts.set(player.team, tc + 1);
            });
            
            let primaryStack = '';
            let maxCount = 0;
            teamCounts.forEach((count, team) => {
                if (count > maxCount) {
                    maxCount = count;
                    primaryStack = `${team} ${count}`;
                }
            });
            
            if (primaryStack && poolAnalysis.stackCounts.size > 0) {
                const stackFrequency = (poolAnalysis.stackCounts.get(primaryStack) || 0) / poolAnalysis.poolSize;
                uniquenessScore += (1 - stackFrequency) * 0.15;
            }
            
            // Low-overlap bonus with already assigned lineups
            let overlapPenalty = 0;
            portfolio.assignedLineups.forEach(assignedLineup => {
                const overlap = countPlayerOverlap(lineup, assignedLineup);
                overlapPenalty += overlap / 6; // 0 to 1 per lineup
            });
            if (portfolio.assignedLineups.length > 0) {
                overlapPenalty /= portfolio.assignedLineups.length; // Average overlap
            }
            
            // 4. Final Score Calculation
            // At diversity 0: pure projection
            // At diversity 10: heavily weighted toward uniqueness and anti-correlation
            const projectionWeight = 1.0;
            const correlationPenalty = diversityFactor * 0.5; // Max 0.5 penalty
            const uniquenessBonus = diversityFactor * 0.3; // Max 0.3 bonus
            const overlapBonus = diversityFactor * 0.3; // Max 0.3 bonus for low overlap
            
            const finalScore = (projectionScore * projectionWeight) 
                - (correlationScore * correlationPenalty)
                + (uniquenessScore * uniquenessBonus)
                - (overlapPenalty * overlapBonus);
            
            return finalScore;
        }
        
        // Count player overlap between two lineups
        function countPlayerOverlap(lineup1, lineup2) {
            const names1 = new Set(lineup1.players.map(p => p.name));
            let overlap = 0;
            lineup2.players.forEach(p => {
                if (names1.has(p.name)) overlap++;
            });
            return overlap;
        }
        
        // Update portfolio exposure after assigning a lineup
        function updatePortfolioExposure(portfolio, lineup, entryFee) {
            lineup.players.forEach(player => {
                // Player exposure
                const currentExposure = portfolio.playerExposure.get(player.name) || 0;
                portfolio.playerExposure.set(player.name, currentExposure + entryFee);
                
                // Captain exposure
                if (player.isCpt) {
                    const currentCptExposure = portfolio.captainExposure.get(player.name) || 0;
                    portfolio.captainExposure.set(player.name, currentCptExposure + entryFee);
                }
            });
            
            // Stack exposure
            const teamCounts = new Map();
            lineup.players.forEach(player => {
                const tc = teamCounts.get(player.team) || 0;
                teamCounts.set(player.team, tc + 1);
            });
            
            let primaryStack = '';
            let maxCount = 0;
            teamCounts.forEach((count, team) => {
                if (count > maxCount) {
                    maxCount = count;
                    primaryStack = `${team} ${count}`;
                }
            });
            
            if (primaryStack) {
                const currentStackExposure = portfolio.stackExposure.get(primaryStack) || 0;
                portfolio.stackExposure.set(primaryStack, currentStackExposure + entryFee);
            }
            
            // Track assigned lineup
            portfolio.assignedLineups.push(lineup);
        }
        
        // Display portfolio exposure summary
        function displayPortfolioSummary(portfolio, totalGppFees) {
            if (totalGppFees === 0) {
                portfolioSummary.style.display = 'none';
                return;
            }
            
            portfolioSummary.style.display = 'block';
            portfolioExposureList.innerHTML = '';
            
            // Sort players by exposure
            const exposureArray = Array.from(portfolio.playerExposure.entries())
                .map(([name, dollars]) => ({ name, dollars, pct: (dollars / totalGppFees) * 100 }))
                .sort((a, b) => b.pct - a.pct)
                .slice(0, 12); // Show top 12
            
            exposureArray.forEach(({ name, pct }) => {
                const item = document.createElement('div');
                item.className = 'exposure-item';
                
                // Color code based on exposure level
                if (pct >= 70) {
                    item.classList.add('high');
                } else if (pct >= 40) {
                    item.classList.add('medium');
                } else {
                    item.classList.add('low');
                }
                
                // Get short name (last name or first initial + last)
                const nameParts = name.split(' ');
                const shortName = nameParts.length > 1 ? nameParts[nameParts.length - 1] : name;
                
                item.innerHTML = `
                    <span class="exposure-name" title="${name}">${shortName}</span>
                    <span class="exposure-pct">${pct.toFixed(0)}%</span>
                `;
                
                portfolioExposureList.appendChild(item);
            });
        }
        
        function assignLineupToEntry(entry, lineup) {
            // Find the captain from the lineup
            const captain = lineup.players.find(p => p.isCpt);
            const flexPlayers = lineup.players.filter(p => !p.isCpt);
            
            // Get the player from the players array to access the correct nameId
            const getCptNameId = (player) => {
                const fullPlayer = players.find(p => p.name === player.name);
                if (fullPlayer && fullPlayer.cptNameId) {
                    return fullPlayer.cptNameId;
                }
                // Fallback to name + id format
                return `${player.name} (${player.id})`;
            };
            
            const getFlexNameId = (player) => {
                const fullPlayer = players.find(p => p.name === player.name);
                if (fullPlayer && fullPlayer.flexNameId) {
                    return fullPlayer.flexNameId;
                }
                // Fallback to name + id format
                return `${player.name} (${player.id})`;
            };
            
            // Update entry with lineup data using correct DK IDs
            entry.cpt = captain ? getCptNameId(captain) : entry.cpt;
            entry.flex = flexPlayers.map(p => getFlexNameId(p));
            entry.salary = lineup.totalSalary;
            entry.projection = lineup.totalProjection;
            
            // Store the lineup reference
            entry.optimizedLineup = lineup;
        }
        
        // Export Entries to DraftKings CSV
        const exportEntriesBtn = document.getElementById('exportEntriesBtn');
        exportEntriesBtn.addEventListener('click', exportEntriesToCSV);
        
        function exportEntriesToCSV() {
            if (entries.length === 0) {
                alert('No entries to export!');
                return;
            }
            
            // Build CSV content
            const headers = ['Entry ID', 'Contest Name', 'Contest ID', 'Entry Fee', 'CPT', 'FLEX', 'FLEX', 'FLEX', 'FLEX', 'FLEX'];
            
            const rows = entries.map(entry => {
                // Ensure we have 5 FLEX slots
                const flexSlots = [...entry.flex];
                while (flexSlots.length < 5) {
                    flexSlots.push('');
                }
                
                return [
                    entry.entryId,
                    entry.contestName,
                    entry.contestId,
                    entry.entryFee,
                    entry.cpt,
                    ...flexSlots.slice(0, 5)
                ];
            });
            
            // Escape CSV fields
            const escapeCSV = (field) => {
                if (field === null || field === undefined) return '';
                const str = String(field);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };
            
            // Build CSV string
            let csv = headers.map(escapeCSV).join(',') + '\n';
            rows.forEach(row => {
                csv += row.map(escapeCSV).join(',') + '\n';
            });
            
            // Create and download file
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `DK_Optimized_Entries_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            // Update status
            optimizeStatus.textContent = `✓ Exported ${entries.length} entries to CSV`;
        }
        
        // Process ALL slates button
        const processAllBtn = document.getElementById('processAllBtn');
        processAllBtn.addEventListener('click', processAllSlates);
        
        async function processAllSlates() {
            // Get all loaded slate numbers
            const loadedSlateNums = Object.keys(slates).map(Number).sort((a, b) => a - b);
            
            if (loadedSlateNums.length === 0) {
                alert('No slates loaded! Please upload at least one DraftKings CSV file.');
                return;
            }
            
            // Disable button and show progress
            processAllBtn.disabled = true;
            processAllBtn.innerHTML = `
                <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="spin">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                </svg>
                Processing...
            `;
            
            const allOptimizedEntries = [];
            let totalSlatesProcessed = 0;
            
            for (const slateNum of loadedSlateNums) {
                const slate = slates[slateNum];
                
                // Skip slates with no entries
                if (!slate.entries || slate.entries.length === 0) {
                    console.log(`Slate ${slateNum}: No entries, skipping`);
                    continue;
                }
                
                // Load this slate's data
                currentSlate = slateNum;
                players = slate.players;
                entries = slate.entries;
                lineups = [];
                
                // Update UI
                updateSlateButtons();
                updateSlateInfo();
                updateSectionBadges();
                
                processAllBtn.innerHTML = `
                    <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="spin">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    Slate ${slateNum}: Generating...
                `;
                
                // Generate lineups for this slate
                await generateLineupsForSlate();
                
                // Save lineups to slate
                slate.lineups = [...lineups];
                
                processAllBtn.innerHTML = `
                    <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24" class="spin">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    Slate ${slateNum}: Optimizing...
                `;
                
                // Optimize entries for this slate
                optimizeEntriesForSlate();
                
                // Save optimized entries back to slate
                slate.entries = [...entries];
                
                // Collect all optimized entries
                allOptimizedEntries.push(...entries);
                
                totalSlatesProcessed++;
                console.log(`Slate ${slateNum}: Processed ${entries.length} entries`);
            }
            
            // Reset button
            processAllBtn.disabled = false;
            processAllBtn.innerHTML = `
                <svg width="18" height="18" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
                </svg>
                ALL
            `;
            
            if (allOptimizedEntries.length === 0) {
                alert('No entries found in any slate!');
                return;
            }
            
            // Export all entries to a single CSV
            exportAllEntriesToCSV(allOptimizedEntries, totalSlatesProcessed);
        }
        
        // Generate lineups without UI updates (for batch processing)
        async function generateLineupsForSlate() {
            if (players.length === 0) return;
            
            lineups = [];
            
            const teams = [...new Set(players.map(p => p.team))];
            if (teams.length < 2) {
                console.log('Need players from at least 2 teams for Showdown');
                return;
            }
            
            const isTimeMode = generationMode === 'time';
            const targetCount = isTimeMode ? Infinity : selectedLineupCount;
            const targetTime = isTimeMode ? selectedTimeSeconds * 1000 : Infinity;
            const startTime = Date.now();
            
            const lineupSet = new Set();
            const sortedPlayers = [...players].sort((a, b) => b.flexProjection - a.flexProjection);
            const playersByCptProj = [...players].sort((a, b) => (b.flexProjection * 1.5) - (a.flexProjection * 1.5));
            
            // PHASE 1: Generate optimal lineups for each captain
            const optimalLineups = [];
            
            for (let cptIdx = 0; cptIdx < playersByCptProj.length; cptIdx++) {
                const captain = playersByCptProj[cptIdx];
                
                const lineup = generateOptimalLineupForCaptain(captain, sortedPlayers, teams);
                if (lineup) {
                    const lineupKey = lineup.players.map(p => p.id + (p.isCpt ? 'C' : '')).sort().join('-');
                    if (!lineupSet.has(lineupKey)) {
                        lineupSet.add(lineupKey);
                        optimalLineups.push(lineup);
                    }
                }
                
                // Yield periodically
                if (cptIdx % 10 === 0) {
                    await new Promise(r => setTimeout(r, 0));
                }
            }
            
            // Sort optimal lineups by projection to find the max
            optimalLineups.sort((a, b) => b.totalProjection - a.totalProjection);
            
            // Calculate projection threshold based on the top lineup
            const maxProjection = optimalLineups.length > 0 ? optimalLineups[0].totalProjection : 0;
            const projectionThreshold = maxProjection * (projectionFloor / 100);
            
            // Filter optimal lineups by salary range and projection floor
            for (const lineup of optimalLineups) {
                if (lineup.totalSalary >= minSalary && 
                    lineup.totalSalary <= maxSalary && 
                    lineup.totalProjection >= projectionThreshold) {
                    lineups.push(lineup);
                }
            }
            
            // PHASE 2: Generate additional lineups with controlled randomization
            const needMoreLineups = isTimeMode || lineups.length < targetCount;
            
            if (needMoreLineups) {
                let attempts = 0;
                let lastLineupCount = lineups.length;
                let stallCounter = 0;
                const maxStallAttempts = 5000;
                
                while (true) {
                    attempts++;
                    
                    const elapsed = Date.now() - startTime;
                    
                    // Time mode: stop when time is up
                    if (isTimeMode && elapsed >= targetTime) break;
                    
                    // Count mode: stop when we have enough
                    if (!isTimeMode && lineups.length >= targetCount) break;
                    
                    // Stall detection
                    if (stallCounter >= maxStallAttempts) break;
                    
                    // Yield periodically
                    if (attempts % 500 === 0) {
                        await new Promise(r => setTimeout(r, 0));
                        
                        if (lineups.length === lastLineupCount) {
                            stallCounter += 500;
                        } else {
                            stallCounter = 0;
                            lastLineupCount = lineups.length;
                        }
                    }
                    
                    const lineup = generateRandomizedLineup(sortedPlayers, teams);
                    if (lineup) {
                        if (lineup.totalSalary < minSalary || lineup.totalSalary > maxSalary) {
                            stallCounter++;
                            continue;
                        }
                        if (lineup.totalProjection < projectionThreshold) {
                            stallCounter++;
                            continue;
                        }
                        
                        const lineupKey = lineup.players.map(p => p.id + (p.isCpt ? 'C' : '')).sort().join('-');
                        if (!lineupSet.has(lineupKey)) {
                            lineupSet.add(lineupKey);
                            lineups.push(lineup);
                            stallCounter = 0;
                        } else {
                            stallCounter++;
                        }
                    } else {
                        stallCounter++;
                    }
                }
            }
            
            // Final sort by projection
            lineups.sort((a, b) => b.totalProjection - a.totalProjection);
        }
        
        // Optimize entries without UI updates (for batch processing)
        function optimizeEntriesForSlate() {
            if (lineups.length === 0 || entries.length === 0) return;
            
            const sortedLineups = [...lineups].sort((a, b) => b.totalProjection - a.totalProjection);
            const topLineup = sortedLineups[0];
            const maxProjection = topLineup.totalProjection;
            
            const cashEntries = [];
            const gppEntries = [];
            
            entries.forEach(entry => {
                if (optimizeMode === 'cash' || isCashGame(entry.contestName)) {
                    cashEntries.push(entry);
                } else {
                    gppEntries.push(entry);
                }
            });
            
            // Assign top lineup to all cash entries
            cashEntries.forEach(entry => {
                assignLineupToEntry(entry, topLineup);
            });
            
            // GPP entries - use Paw Patrol or Balanced mode
            if (optimizeMode === 'paw-patrol') {
                // Portfolio optimization for GPP entries
                gppEntries.sort((a, b) => {
                    const feeA = parseFloat(a.entryFee.replace(/[$,]/g, '')) || 0;
                    const feeB = parseFloat(b.entryFee.replace(/[$,]/g, '')) || 0;
                    return feeB - feeA;
                });
                
                const totalGppFees = gppEntries.reduce((sum, e) => {
                    return sum + (parseFloat(e.entryFee.replace(/[$,]/g, '')) || 0);
                }, 0);
                
                const poolSize = Math.min(200, sortedLineups.length);
                const candidatePool = sortedLineups.slice(0, poolSize);
                const poolAnalysis = analyzeLineupPool(candidatePool);
                
                const portfolio = {
                    playerExposure: new Map(),
                    captainExposure: new Map(),
                    stackExposure: new Map(),
                    assignedLineups: []
                };
                
                gppEntries.forEach(entry => {
                    const entryFee = parseFloat(entry.entryFee.replace(/[$,]/g, '')) || 0.01;
                    
                    let bestLineup = null;
                    let bestScore = -Infinity;
                    
                    candidatePool.forEach(lineup => {
                        const score = scoreLineupForPortfolio(
                            lineup, portfolio, maxProjection, totalGppFees,
                            poolAnalysis, diversityStrength
                        );
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestLineup = lineup;
                        }
                    });
                    
                    if (bestLineup) {
                        assignLineupToEntry(entry, bestLineup);
                        updatePortfolioExposure(portfolio, bestLineup, entryFee);
                    }
                });
                
                // Display portfolio summary for this slate
                displayPortfolioSummary(portfolio, totalGppFees);
            } else {
                // Balanced mode - unique lineups in projection order
                let gppLineupIndex = 0;
                const usedLineups = new Set();
                
                gppEntries.forEach(entry => {
                    while (gppLineupIndex < sortedLineups.length && usedLineups.has(gppLineupIndex)) {
                        gppLineupIndex++;
                    }
                    
                    if (gppLineupIndex < sortedLineups.length) {
                        assignLineupToEntry(entry, sortedLineups[gppLineupIndex]);
                        usedLineups.add(gppLineupIndex);
                        gppLineupIndex++;
                    } else {
                        assignLineupToEntry(entry, sortedLineups[gppLineupIndex % sortedLineups.length]);
                        gppLineupIndex++;
                    }
                });
            }
        }
        
        // Export all entries from all slates to a single CSV
        function exportAllEntriesToCSV(allEntries, slatesProcessed) {
            const headers = ['Entry ID', 'Contest Name', 'Contest ID', 'Entry Fee', 'CPT', 'FLEX', 'FLEX', 'FLEX', 'FLEX', 'FLEX'];
            
            const rows = allEntries.map(entry => {
                const flexSlots = [...entry.flex];
                while (flexSlots.length < 5) {
                    flexSlots.push('');
                }
                
                return [
                    entry.entryId,
                    entry.contestName,
                    entry.contestId,
                    entry.entryFee,
                    entry.cpt,
                    ...flexSlots.slice(0, 5)
                ];
            });
            
            const escapeCSV = (field) => {
                if (field === null || field === undefined) return '';
                const str = String(field);
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };
            
            let csv = headers.map(escapeCSV).join(',') + '\n';
            rows.forEach(row => {
                csv += row.map(escapeCSV).join(',') + '\n';
            });
            
            // Create and download file
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `DK_All_Entries_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert(`✓ Exported ${allEntries.length} entries from ${slatesProcessed} slates!`);
        }

        async function generateLineups() {
            if (players.length === 0) return;

            generateBtn.disabled = true;
            progressContainer.classList.add('active');
            lineupsCard.style.display = 'block';
            lineups = [];
            currentPage = 1;

            const teams = [...new Set(players.map(p => p.team))];
            if (teams.length < 2) {
                alert('Need players from at least 2 teams for Showdown');
                generateBtn.disabled = false;
                progressContainer.classList.remove('active');
                return;
            }

            const isTimeMode = generationMode === 'time';
            const targetCount = isTimeMode ? Infinity : selectedLineupCount;
            const targetTime = isTimeMode ? selectedTimeSeconds * 1000 : Infinity;
            const startTime = Date.now();
            
            const lineupSet = new Set();

            // Sort players by projection for greedy selection
            const sortedPlayers = [...players].sort((a, b) => b.flexProjection - a.flexProjection);
            
            // PHASE 1: Generate ALL optimal lineups deterministically to find the true top lineups
            progressText.textContent = 'Finding optimal lineups...';
            progressFill.style.width = '10%';
            await new Promise(r => setTimeout(r, 0));

            const optimalLineups = [];
            
            // Try each player as captain, sorted by CPT projection (highest first)
            const playersByCptProj = [...players].sort((a, b) => (b.flexProjection * 1.5) - (a.flexProjection * 1.5));
            
            for (let cptIdx = 0; cptIdx < playersByCptProj.length; cptIdx++) {
                const captain = playersByCptProj[cptIdx];
                
                // Update progress
                if (cptIdx % 5 === 0) {
                    const elapsed = Date.now() - startTime;
                    if (isTimeMode) {
                        const timeProgress = Math.min((elapsed / targetTime) * 100, 100);
                        progressFill.style.width = timeProgress + '%';
                        progressText.textContent = `Finding optimal lineups... ${Math.ceil((targetTime - elapsed) / 1000)}s remaining`;
                    } else {
                        progressFill.style.width = (10 + (cptIdx / playersByCptProj.length) * 40) + '%';
                        progressText.textContent = `Analyzing captain ${cptIdx + 1}/${playersByCptProj.length}...`;
                    }
                    await new Promise(r => setTimeout(r, 0));
                }
                
                // Get the best possible lineup with this captain using combinatorial search
                const lineup = generateOptimalLineupForCaptain(captain, sortedPlayers, teams);
                if (lineup) {
                    const lineupKey = lineup.players.map(p => p.id + (p.isCpt ? 'C' : '')).sort().join('-');
                    if (!lineupSet.has(lineupKey)) {
                        lineupSet.add(lineupKey);
                        optimalLineups.push(lineup);
                    }
                }
            }

            // Sort optimal lineups by projection to find the max
            optimalLineups.sort((a, b) => b.totalProjection - a.totalProjection);
            
            // Calculate projection threshold based on the top lineup
            const maxProjection = optimalLineups.length > 0 ? optimalLineups[0].totalProjection : 0;
            const projectionThreshold = maxProjection * (projectionFloor / 100);
            
            // Filter optimal lineups by salary range and projection floor
            for (const lineup of optimalLineups) {
                if (lineup.totalSalary >= minSalary && 
                    lineup.totalSalary <= maxSalary && 
                    lineup.totalProjection >= projectionThreshold) {
                    lineups.push(lineup);
                }
            }

            // PHASE 2: If we need more lineups, generate additional ones with controlled randomization
            const needMoreLineups = isTimeMode || lineups.length < targetCount;
            
            if (needMoreLineups) {
                progressText.textContent = isTimeMode ? 'Generating lineups...' : 'Generating additional lineups...';
                progressFill.style.width = '60%';
                await new Promise(r => setTimeout(r, 0));

                let attempts = 0;
                let lastLineupCount = lineups.length;
                let stallCounter = 0;
                const maxStallAttempts = 5000; // Stop if we go 5000 attempts without finding a new lineup
                
                while (true) {
                    attempts++;
                    
                    // Check stopping conditions
                    const elapsed = Date.now() - startTime;
                    
                    // Time mode: stop when time is up
                    if (isTimeMode && elapsed >= targetTime) {
                        progressText.textContent = `Time's up! Generated ${lineups.length} lineups`;
                        break;
                    }
                    
                    // Count mode: stop when we have enough
                    if (!isTimeMode && lineups.length >= targetCount) {
                        break;
                    }
                    
                    // Stall detection: stop if we can't find new lineups
                    if (stallCounter >= maxStallAttempts) {
                        progressText.textContent = `Stopped early - found all unique lineups (${lineups.length})`;
                        break;
                    }

                    // Update progress periodically
                    if (attempts % 500 === 0) {
                        if (isTimeMode) {
                            const timeProgress = Math.min((elapsed / targetTime) * 100, 100);
                            const remaining = Math.max(0, Math.ceil((targetTime - elapsed) / 1000));
                            progressFill.style.width = timeProgress + '%';
                            progressText.textContent = `Generated ${lineups.length} lineups... ${remaining}s remaining`;
                        } else {
                            const progress = 60 + Math.min((lineups.length / targetCount) * 40, 39);
                            progressFill.style.width = progress + '%';
                            progressText.textContent = `Generated ${lineups.length} of ${targetCount} lineups...`;
                        }
                        await new Promise(r => setTimeout(r, 0));
                        
                        // Check if we found any new lineups in this batch
                        if (lineups.length === lastLineupCount) {
                            stallCounter += 500;
                        } else {
                            stallCounter = 0;
                            lastLineupCount = lineups.length;
                        }
                    }

                    const lineup = generateRandomizedLineup(sortedPlayers, teams);
                    if (lineup) {
                        // Check salary and projection constraints BEFORE adding
                        if (lineup.totalSalary < minSalary || lineup.totalSalary > maxSalary) {
                            stallCounter++;
                            continue;
                        }
                        if (lineup.totalProjection < projectionThreshold) {
                            stallCounter++;
                            continue;
                        }
                        
                        const lineupKey = lineup.players.map(p => p.id + (p.isCpt ? 'C' : '')).sort().join('-');
                        if (!lineupSet.has(lineupKey)) {
                            lineupSet.add(lineupKey);
                            lineups.push(lineup);
                            stallCounter = 0;
                        } else {
                            stallCounter++;
                        }
                    } else {
                        stallCounter++;
                    }
                }
            }

            // Final sort by total projection
            lineups.sort((a, b) => b.totalProjection - a.totalProjection);

            // Update stats
            progressFill.style.width = '100%';
            const finalTime = ((Date.now() - startTime) / 1000).toFixed(1);
            progressText.textContent = `Complete! ${lineups.length} lineups in ${finalTime}s`;
            
            document.getElementById('lineupsGenerated').textContent = lineups.length;
            document.getElementById('topProjection').textContent = lineups.length > 0 ? lineups[0].totalProjection.toFixed(2) : '0.00';
            
            const avgProj = lineups.length > 0 
                ? (lineups.reduce((sum, l) => sum + l.totalProjection, 0) / lineups.length).toFixed(2)
                : '0.00';
            document.getElementById('avgProjection').textContent = avgProj;

            renderLineups();
            
            // Save lineups to current slate
            if (currentSlate && slates[currentSlate]) {
                slates[currentSlate].lineups = [...lineups];
            }
            
            // Update section badges to show lineup count
            updateSectionBadges();
            
            // Enable optimize button if we have entries
            if (entries.length > 0) {
                document.getElementById('optimizeBtn').disabled = false;
                document.getElementById('optimizeStatus').textContent = `${lineups.length} lineups ready to assign`;
            }
            
            setTimeout(() => {
                progressContainer.classList.remove('active');
                generateBtn.disabled = false;
            }, 1500);
        }

        // Generate the optimal lineup for a given captain by trying all valid combinations
        function generateOptimalLineupForCaptain(captain, sortedPlayers, teams) {
            const cptSalary = Math.round(captain.flexSalary * 1.5);
            const remainingSalary = SALARY_CAP - cptSalary;
            
            // Get available players (excluding captain), sorted by projection
            const available = sortedPlayers.filter(p => p.id !== captain.id);
            
            // Find the best 5-player combination using combinatorial search
            const bestCombo = findBestFivePlayers(available, remainingSalary, captain.team, cptSalary);
            
            if (!bestCombo) return null;
            
            const totalSalary = cptSalary + bestCombo.reduce((sum, p) => sum + p.flexSalary, 0);
            const totalProjection = (captain.flexProjection * 1.5) + bestCombo.reduce((sum, p) => sum + p.flexProjection, 0);
            
            return {
                players: [
                    { ...captain, isCpt: true, cptSalary },
                    ...bestCombo.map(p => ({ ...p, isCpt: false }))
                ],
                totalSalary,
                totalProjection
            };
        }

        // Find the best 5 FLEX players using exhaustive search of top candidates
        function findBestFivePlayers(players, maxSalary, captainTeam) {
            let bestCombo = null;
            let bestProjection = -1;
            
            // Take top N players by projection as candidates (covers all realistic optimal lineups)
            // C(25,5) = 53,130 combinations - very fast to compute
            const candidates = players.slice(0, 25);
            const n = candidates.length;
            
            if (n < 5) return null;
            
            // Try all combinations of 5 players from candidates
            for (let i = 0; i < n - 4; i++) {
                const p1 = candidates[i];
                const sal1 = p1.flexSalary;
                if (sal1 > maxSalary) continue;
                
                for (let j = i + 1; j < n - 3; j++) {
                    const p2 = candidates[j];
                    const sal2 = sal1 + p2.flexSalary;
                    if (sal2 > maxSalary) continue;
                    
                    for (let k = j + 1; k < n - 2; k++) {
                        const p3 = candidates[k];
                        const sal3 = sal2 + p3.flexSalary;
                        if (sal3 > maxSalary) continue;
                        
                        for (let l = k + 1; l < n - 1; l++) {
                            const p4 = candidates[l];
                            const sal4 = sal3 + p4.flexSalary;
                            if (sal4 > maxSalary) continue;
                            
                            for (let m = l + 1; m < n; m++) {
                                const p5 = candidates[m];
                                const totalSalary = sal4 + p5.flexSalary;
                                
                                if (totalSalary > maxSalary) continue;
                                
                                // Check both teams are represented
                                const teamsUsed = new Set([captainTeam, p1.team, p2.team, p3.team, p4.team, p5.team]);
                                if (teamsUsed.size < 2) continue;
                                
                                const totalProjection = p1.flexProjection + p2.flexProjection + p3.flexProjection + p4.flexProjection + p5.flexProjection;
                                
                                if (totalProjection > bestProjection) {
                                    bestProjection = totalProjection;
                                    bestCombo = [p1, p2, p3, p4, p5];
                                }
                            }
                        }
                    }
                }
            }
            
            return bestCombo;
        }

        // Generate a randomized lineup for diversity (used after optimal lineups are found)
        function generateRandomizedLineup(sortedPlayers, teams) {
            // Pick a captain - weighted random from top players
            const captainPool = sortedPlayers.slice(0, Math.min(25, sortedPlayers.length));
            const weights = captainPool.map((_, i) => Math.pow(0.9, i));
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            let rand = Math.random() * totalWeight;
            let captainIdx = 0;
            for (let i = 0; i < weights.length; i++) {
                rand -= weights[i];
                if (rand <= 0) {
                    captainIdx = i;
                    break;
                }
            }
            
            const captain = captainPool[captainIdx];
            const cptSalary = Math.round(captain.flexSalary * 1.5);
            let remainingSalary = SALARY_CAP - cptSalary;
            const usedIds = new Set([captain.id]);
            const usedTeams = new Set([captain.team]);
            const flexPlayers = [];

            // Get available players with some shuffling for diversity
            const available = sortedPlayers.filter(p => p.id !== captain.id);
            
            // Weighted shuffle - higher projected players more likely to stay near top
            const shuffled = [...available];
            for (let i = Math.min(15, shuffled.length - 1); i > 0; i--) {
                if (Math.random() < 0.6) continue; // 60% chance to keep position
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }

            // Select 5 FLEX players
            for (const player of shuffled) {
                if (flexPlayers.length >= 5) break;
                if (usedIds.has(player.id)) continue;
                if (player.flexSalary > remainingSalary) continue;

                const spotsLeft = 5 - flexPlayers.length;
                const needOtherTeam = usedTeams.size === 1 && spotsLeft === 1;
                
                if (needOtherTeam && player.team === captain.team) continue;

                flexPlayers.push(player);
                usedIds.add(player.id);
                usedTeams.add(player.team);
                remainingSalary -= player.flexSalary;
            }

            // Validate lineup
            if (flexPlayers.length !== 5) return null;
            if (usedTeams.size < 2) return null;

            const totalSalary = cptSalary + flexPlayers.reduce((sum, p) => sum + p.flexSalary, 0);
            if (totalSalary > SALARY_CAP) return null;

            const totalProjection = (captain.flexProjection * 1.5) + flexPlayers.reduce((sum, p) => sum + p.flexProjection, 0);

            return {
                players: [
                    { ...captain, isCpt: true, cptSalary: cptSalary },
                    ...flexPlayers.map(p => ({ ...p, isCpt: false }))
                ],
                totalSalary,
                totalProjection
            };
        }

        function renderLineups() {
            document.getElementById('lineupCountDisplay').textContent = `${lineups.length} lineups`;

            // Update header sort indicators
            const salaryHeader = document.querySelector('.lineup-row.header [data-sort="salary"]');
            const pointsHeader = document.querySelector('.lineup-row.header [data-sort="points"]');
            const rankHeader = document.querySelector('.lineup-row.header [data-sort="rank"]');
            
            [salaryHeader, pointsHeader, rankHeader].forEach(h => {
                if (h) {
                    h.classList.remove('sort-asc', 'sort-desc');
                    const col = h.dataset.sort;
                    const sortCol = currentSort.column === 'rank' ? 'rank' : currentSort.column;
                    if (col === sortCol || (col === 'points' && currentSort.column === 'points') || (col === 'salary' && currentSort.column === 'salary')) {
                        if (currentSort.column === col) {
                            h.classList.add(currentSort.direction === 'desc' ? 'sort-desc' : 'sort-asc');
                            h.textContent = h.dataset.sort.charAt(0).toUpperCase() + h.dataset.sort.slice(1) + (currentSort.direction === 'desc' ? ' ↓' : ' ↑');
                        } else {
                            h.textContent = h.dataset.sort.charAt(0).toUpperCase() + h.dataset.sort.slice(1) + ' ⇅';
                        }
                    } else {
                        h.textContent = h.dataset.sort.charAt(0).toUpperCase() + h.dataset.sort.slice(1) + ' ⇅';
                    }
                }
            });

            const paginationTop = document.getElementById('paginationTop');

            if (lineups.length === 0) {
                paginationTop.style.display = 'none';
                lineupRows.innerHTML = `
                    <div class="empty-state">
                        <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                        </svg>
                        <h4>No Lineups Generated</h4>
                        <p>Click "Generate Lineups" to create optimized lineups</p>
                    </div>
                `;
                return;
            }

            // Sort lineups based on current sort
            const sortedLineups = [...lineups];
            if (currentSort.column === 'points') {
                sortedLineups.sort((a, b) => currentSort.direction === 'desc' 
                    ? b.totalProjection - a.totalProjection 
                    : a.totalProjection - b.totalProjection);
            } else if (currentSort.column === 'salary') {
                sortedLineups.sort((a, b) => currentSort.direction === 'desc' 
                    ? b.totalSalary - a.totalSalary 
                    : a.totalSalary - b.totalSalary);
            } else if (currentSort.column === 'rank') {
                // Rank is based on original projection order
                if (currentSort.direction === 'asc') {
                    sortedLineups.reverse();
                }
            }

            // Pagination calculations
            const totalPages = Math.ceil(sortedLineups.length / lineupsPerPage);
            currentPage = Math.min(currentPage, totalPages);
            currentPage = Math.max(currentPage, 1);
            
            const startIdx = (currentPage - 1) * lineupsPerPage;
            const endIdx = Math.min(startIdx + lineupsPerPage, sortedLineups.length);
            const pageLineups = sortedLineups.slice(startIdx, endIdx);

            // Show/hide pagination
            if (sortedLineups.length > lineupsPerPage) {
                paginationTop.style.display = 'flex';
                document.getElementById('pageInfoTop').textContent = `Page ${currentPage} of ${totalPages}`;
                document.getElementById('showingInfoTop').textContent = `Showing ${startIdx + 1}-${endIdx} of ${sortedLineups.length}`;
                document.getElementById('prevPageTop').disabled = currentPage <= 1;
                document.getElementById('nextPageTop').disabled = currentPage >= totalPages;
            } else {
                paginationTop.style.display = 'none';
            }

            lineupRows.innerHTML = pageLineups.map((lineup, idx) => {
                const cpt = lineup.players[0];
                const flex = lineup.players.slice(1);
                const actualRank = startIdx + idx + 1;
                
                return `
                    <div class="lineup-row">
                        <div class="lineup-rank">#${actualRank}</div>
                        <div class="lineup-player">
                            <span class="lineup-player-name">${cpt.name}</span>
                            <span class="lineup-player-meta">
                                <span class="position-badge cpt">CPT</span>
                                ${cpt.team} • $${(cpt.cptSalary || Math.round(cpt.flexSalary * 1.5)).toLocaleString()} • <span style="color: var(--accent-tertiary); font-weight: 600;">${(cpt.flexProjection * 1.5).toFixed(1)}</span>
                            </span>
                        </div>
                        ${flex.map(p => `
                            <div class="lineup-player">
                                <span class="lineup-player-name">${p.name}</span>
                                <span class="lineup-player-meta">
                                    <span class="position-badge flex">FLEX</span>
                                    ${p.team} • $${p.flexSalary.toLocaleString()} • <span style="color: var(--accent-primary); font-weight: 600;">${p.flexProjection.toFixed(1)}</span>
                                </span>
                            </div>
                        `).join('')}
                        <div class="lineup-salary">$${lineup.totalSalary.toLocaleString()}</div>
                        <div class="lineup-points">${lineup.totalProjection.toFixed(2)}</div>
                    </div>
                `;
            }).join('');
        }

        // Pagination event listeners
        document.getElementById('prevPageTop').addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                renderLineups();
                document.getElementById('lineupOutput').scrollTop = 0;
            }
        });

        document.getElementById('nextPageTop').addEventListener('click', () => {
            const totalPages = Math.ceil(lineups.length / lineupsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                renderLineups();
                document.getElementById('lineupOutput').scrollTop = 0;
            }
        });

        // Sortable columns
        document.querySelector('.lineup-row.header').addEventListener('click', (e) => {
            const sortable = e.target.closest('.sortable');
            if (!sortable) return;

            const column = sortable.dataset.sort;
            
            // Toggle direction
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'desc';
            }

            // Reset to page 1 when sort changes
            currentPage = 1;

            // Update header classes
            document.querySelectorAll('.lineup-row.header .sortable').forEach(el => {
                el.classList.remove('sort-asc', 'sort-desc');
            });
            sortable.classList.add(currentSort.direction === 'desc' ? 'sort-desc' : 'sort-asc');

            renderLineups();
        });

        // Export to CSV
        document.getElementById('exportBtn').addEventListener('click', () => {
            if (lineups.length === 0) return;

            const headers = ['CPT', 'FLEX', 'FLEX', 'FLEX', 'FLEX', 'FLEX', 'Salary', 'Projection'];
            const rows = lineups.map(lineup => {
                const cpt = lineup.players[0];
                const flex = lineup.players.slice(1);
                return [
                    cpt.name,
                    ...flex.map(p => p.name),
                    lineup.totalSalary,
                    lineup.totalProjection.toFixed(2)
                ];
            });

            const csvContent = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `showdown_lineups_${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        });

        // Clear Lineups
        document.getElementById('clearLineupsBtn').addEventListener('click', () => {
            lineups = [];
            currentPage = 1;
            document.getElementById('lineupsGenerated').textContent = '0';
            document.getElementById('topProjection').textContent = '0.00';
            document.getElementById('avgProjection').textContent = '0.00';
            document.getElementById('lineupCountDisplay').textContent = '0 lineups';
            document.getElementById('paginationTop').style.display = 'none';
            lineupRows.innerHTML = `
                <div class="empty-state">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                    </svg>
                    <h4>No Lineups Generated</h4>
                    <p>Click "Generate Lineups" to create optimized lineups</p>
                </div>
            `;
        });

        // Initialize - show empty state
        renderPlayerPool();

        // Tab Navigation
        document.querySelectorAll('.main-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update active tab
                document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Show corresponding content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName + 'Tab').classList.add('active');
            });
        });

        // ==========================================
        // PLAYER DATA TAB FUNCTIONALITY
        // ==========================================
        
        // Player Data Global State
        const playerGameData = {
            QB: [],
            RB: [],
            WR: [],
            TE: [],
            DST: []
        };
        
        let correlationMatrix = [];
        let teamCorrelations = {}; // Organized by team
        let positionPairCorrelations = {}; // Organized by position pair
        
        // NFL Teams Database with colors and logos
        const NFL_TEAMS = {
            'ARI': { name: 'Cardinals', city: 'Arizona', primary: '#97233F', secondary: '#000000', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/ari.png' },
            'ATL': { name: 'Falcons', city: 'Atlanta', primary: '#A71930', secondary: '#000000', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/atl.png' },
            'BAL': { name: 'Ravens', city: 'Baltimore', primary: '#241773', secondary: '#000000', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/bal.png' },
            'BUF': { name: 'Bills', city: 'Buffalo', primary: '#00338D', secondary: '#C60C30', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/buf.png' },
            'CAR': { name: 'Panthers', city: 'Carolina', primary: '#0085CA', secondary: '#101820', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/car.png' },
            'CHI': { name: 'Bears', city: 'Chicago', primary: '#0B162A', secondary: '#C83803', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/chi.png' },
            'CIN': { name: 'Bengals', city: 'Cincinnati', primary: '#FB4F14', secondary: '#000000', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/cin.png' },
            'CLE': { name: 'Browns', city: 'Cleveland', primary: '#311D00', secondary: '#FF3C00', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/cle.png' },
            'DAL': { name: 'Cowboys', city: 'Dallas', primary: '#003594', secondary: '#869397', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/dal.png' },
            'DEN': { name: 'Broncos', city: 'Denver', primary: '#FB4F14', secondary: '#002244', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/den.png' },
            'DET': { name: 'Lions', city: 'Detroit', primary: '#0076B6', secondary: '#B0B7BC', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/det.png' },
            'GB': { name: 'Packers', city: 'Green Bay', primary: '#203731', secondary: '#FFB612', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/gb.png' },
            'HOU': { name: 'Texans', city: 'Houston', primary: '#03202F', secondary: '#A71930', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/hou.png' },
            'IND': { name: 'Colts', city: 'Indianapolis', primary: '#002C5F', secondary: '#A2AAAD', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/ind.png' },
            'JAX': { name: 'Jaguars', city: 'Jacksonville', primary: '#006778', secondary: '#D7A22A', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/jax.png' },
            'KC': { name: 'Chiefs', city: 'Kansas City', primary: '#E31837', secondary: '#FFB81C', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/kc.png' },
            'LV': { name: 'Raiders', city: 'Las Vegas', primary: '#000000', secondary: '#A5ACAF', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/lv.png' },
            'LAC': { name: 'Chargers', city: 'Los Angeles', primary: '#0080C6', secondary: '#FFC20E', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/lac.png' },
            'LAR': { name: 'Rams', city: 'Los Angeles', primary: '#003594', secondary: '#FFA300', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/lar.png' },
            'MIA': { name: 'Dolphins', city: 'Miami', primary: '#008E97', secondary: '#FC4C02', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/mia.png' },
            'MIN': { name: 'Vikings', city: 'Minnesota', primary: '#4F2683', secondary: '#FFC62F', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/min.png' },
            'NE': { name: 'Patriots', city: 'New England', primary: '#002244', secondary: '#C60C30', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/ne.png' },
            'NO': { name: 'Saints', city: 'New Orleans', primary: '#D3BC8D', secondary: '#101820', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/no.png' },
            'NYG': { name: 'Giants', city: 'New York', primary: '#0B2265', secondary: '#A71930', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/nyg.png' },
            'NYJ': { name: 'Jets', city: 'New York', primary: '#125740', secondary: '#000000', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/nyj.png' },
            'PHI': { name: 'Eagles', city: 'Philadelphia', primary: '#004C54', secondary: '#A5ACAF', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/phi.png' },
            'PIT': { name: 'Steelers', city: 'Pittsburgh', primary: '#FFB612', secondary: '#101820', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/pit.png' },
            'SF': { name: '49ers', city: 'San Francisco', primary: '#AA0000', secondary: '#B3995D', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/sf.png' },
            'SEA': { name: 'Seahawks', city: 'Seattle', primary: '#002244', secondary: '#69BE28', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/sea.png' },
            'TB': { name: 'Buccaneers', city: 'Tampa Bay', primary: '#D50A0A', secondary: '#FF7900', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/tb.png' },
            'TEN': { name: 'Titans', city: 'Tennessee', primary: '#0C2340', secondary: '#4B92DB', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/ten.png' },
            'WAS': { name: 'Commanders', city: 'Washington', primary: '#5A1414', secondary: '#FFB612', logo: 'https://a.espncdn.com/i/teamlogos/nfl/500/was.png' }
        };
        
        // Setup upload handlers for each position
        const positions = ['QB', 'RB', 'WR', 'TE', 'DST'];
        
        positions.forEach(pos => {
            const zone = document.getElementById(`pd${pos}Zone`);
            const input = document.getElementById(`pd${pos}Input`);
            const card = document.getElementById(`pd${pos}Card`);
            const status = document.getElementById(`pd${pos}Status`);
            
            // Click to upload
            zone.addEventListener('click', () => input.click());
            
            // Drag and drop
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });
            
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });
            
            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.name.endsWith('.csv')) {
                    handlePlayerDataFile(file, pos);
                }
            });
            
            // File input change
            input.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handlePlayerDataFile(file, pos);
                }
                input.value = '';
            });
        });
        
        function handlePlayerDataFile(file, position) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const csvData = e.target.result;
                parsePlayerDataCSV(csvData, position);
                updatePlayerDataUI(position, file.name);
                checkAllFilesLoaded();
            };
            reader.readAsText(file);
        }
        
        // Note: Raw player data is NOT persisted (too large for localStorage)
        // Only computed correlations are saved
        
        function parsePlayerDataCSV(csvData, position) {
            const lines = csvData.split('\n');
            if (lines.length < 2) return;
            
            const headers = lines[0].split(',').map(h => h.trim().toUpperCase());
            
            // Find column indices
            const playerIdx = headers.findIndex(h => h === 'PLAYER');
            const teamIdx = headers.findIndex(h => h === 'TEAM');
            const weekIdx = headers.findIndex(h => h === 'WEEK');
            const oppIdx = headers.findIndex(h => h === 'OPPONENT');
            const fptsIdx = headers.findIndex(h => h === 'FPTS');
            
            if (fptsIdx === -1) {
                console.error(`No FPTS column found for ${position}`);
                return;
            }
            
            const records = [];
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                // Handle CSV properly (commas in quoted strings)
                const row = parseCSVLine(line);
                
                if (row.length <= fptsIdx) continue;
                
                const playerName = row[playerIdx]?.trim();
                const team = row[teamIdx]?.trim();
                const week = parseInt(row[weekIdx]?.trim());
                const opponent = row[oppIdx]?.trim();
                const fpts = parseFloat(row[fptsIdx]?.trim());
                
                if (playerName && !isNaN(week) && !isNaN(fpts)) {
                    records.push({
                        name: playerName,
                        position: position,
                        team: team,
                        week: week,
                        opponent: opponent,
                        fpts: fpts
                    });
                }
            }
            
            playerGameData[position] = records;
            console.log(`Loaded ${records.length} ${position} records`);
        }
        
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current);
            
            return result;
        }
        
        function updatePlayerDataUI(position, filename) {
            const card = document.getElementById(`pd${position}Card`);
            const status = document.getElementById(`pd${position}Status`);
            const recordCount = playerGameData[position].length;
            
            card.classList.add('loaded');
            status.innerHTML = `
                <div class="pd-file-info">
                    <span class="pd-status-text">✓ ${recordCount} records loaded</span>
                    <span class="remove-btn" onclick="removePlayerData('${position}')">
                        <svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </span>
                </div>
            `;
            
            updatePlayerDataStats();
        }
        
        function removePlayerData(position) {
            playerGameData[position] = [];
            const card = document.getElementById(`pd${position}Card`);
            const status = document.getElementById(`pd${position}Status`);
            
            card.classList.remove('loaded');
            status.innerHTML = '<span class="pd-status-text">No file loaded</span>';
            
            updatePlayerDataStats();
            checkAllFilesLoaded();
        }
        
        function updatePlayerDataStats() {
            let totalRecords = 0;
            const uniquePlayers = new Set();
            const teams = new Set();
            
            positions.forEach(pos => {
                totalRecords += playerGameData[pos].length;
                playerGameData[pos].forEach(record => {
                    uniquePlayers.add(`${record.name}-${record.team}`);
                    if (record.team) teams.add(record.team);
                });
            });
            
            document.getElementById('pdTotalRecords').textContent = totalRecords.toLocaleString();
            document.getElementById('pdUniquePlayers').textContent = uniquePlayers.size;
            document.getElementById('pdTeams').textContent = teams.size;
        }
        
        function checkAllFilesLoaded() {
            const allLoaded = positions.every(pos => playerGameData[pos].length > 0);
            const computeBtn = document.getElementById('computeCorrelationsBtn');
            computeBtn.disabled = !allLoaded;
            
            const statusEl = document.getElementById('pdStatus');
            if (allLoaded) {
                statusEl.textContent = 'Ready!';
                statusEl.style.color = 'var(--accent-primary)';
            } else {
                const loadedCount = positions.filter(pos => playerGameData[pos].length > 0).length;
                statusEl.textContent = `${loadedCount}/5 Files`;
                statusEl.style.color = '';
            }
        }
        
        // Compute Correlations Button
        document.getElementById('computeCorrelationsBtn').addEventListener('click', computeCorrelations);
        
        function computeCorrelations() {
            console.log('Computing correlations...');
            
            // Combine all player data
            const allRecords = [];
            positions.forEach(pos => {
                allRecords.push(...playerGameData[pos]);
            });
            
            // Group by player
            const playerGames = {};
            allRecords.forEach(record => {
                const key = `${record.name}|${record.team}|${record.position}`;
                if (!playerGames[key]) {
                    playerGames[key] = [];
                }
                playerGames[key].push(record);
            });
            
            // Calculate correlations between teammates
            const correlations = [];
            const playerKeys = Object.keys(playerGames);
            
            for (let i = 0; i < playerKeys.length; i++) {
                const key1 = playerKeys[i];
                const [name1, team1, pos1] = key1.split('|');
                const records1 = playerGames[key1];
                
                for (let j = i + 1; j < playerKeys.length; j++) {
                    const key2 = playerKeys[j];
                    const [name2, team2, pos2] = key2.split('|');
                    const records2 = playerGames[key2];
                    
                    // Only correlate teammates
                    if (team1 !== team2) continue;
                    
                    // Find common weeks
                    const weeks1 = {};
                    records1.forEach(r => { weeks1[r.week] = r.fpts; });
                    
                    const weeks2 = {};
                    records2.forEach(r => { weeks2[r.week] = r.fpts; });
                    
                    const commonWeeks = Object.keys(weeks1).filter(w => weeks2[w] !== undefined);
                    
                    if (commonWeeks.length >= 5) {
                        const x = commonWeeks.map(w => weeks1[w]);
                        const y = commonWeeks.map(w => weeks2[w]);
                        
                        const corr = pearsonCorrelation(x, y);
                        
                        if (corr !== null) {
                            correlations.push({
                                player1: name1,
                                pos1: pos1,
                                player2: name2,
                                pos2: pos2,
                                team: team1,
                                correlation: corr,
                                games: commonWeeks.length
                            });
                        }
                    }
                }
            }
            
            // Sort by absolute correlation
            correlations.sort((a, b) => Math.abs(b.correlation) - Math.abs(a.correlation));
            
            correlationMatrix = correlations;
            
            // Organize by team
            organizeByTeam(correlations);
            
            // Organize by position pair
            organizeByPositionPair(correlations);
            
            // Save correlations to localStorage
            saveCorrelationsToStorage();
            
            // Update UI
            document.getElementById('pdCorrelations').textContent = correlations.length;
            document.getElementById('correlationResultsCard').style.display = 'block';
            document.getElementById('teamCardsContainer').style.display = 'block';
            document.getElementById('positionPairCard').style.display = 'block';
            
            // Render all sections
            renderPositionMatrix(correlations);
            renderTeamCards();
            renderPositionPairTable('QB-WR');
            
            console.log(`Computed ${correlations.length} correlations`);
        }
        
        // Save correlations to localStorage
        function saveCorrelationsToStorage() {
            try {
                localStorage.setItem('maddenCorrelationMatrix', JSON.stringify(correlationMatrix));
                localStorage.setItem('maddenTeamCorrelations', JSON.stringify(teamCorrelations));
                localStorage.setItem('maddenPositionPairCorrelations', JSON.stringify(positionPairCorrelations));
                console.log('Correlations saved to localStorage');
            } catch (e) {
                console.error('Failed to save correlations:', e);
            }
        }
        
        // Load correlations from localStorage
        function loadCorrelationsFromStorage() {
            try {
                const matrix = localStorage.getItem('maddenCorrelationMatrix');
                const teams = localStorage.getItem('maddenTeamCorrelations');
                const pairs = localStorage.getItem('maddenPositionPairCorrelations');
                
                if (matrix && teams && pairs) {
                    correlationMatrix = JSON.parse(matrix);
                    teamCorrelations = JSON.parse(teams);
                    positionPairCorrelations = JSON.parse(pairs);
                    
                    // Update UI
                    document.getElementById('pdCorrelations').textContent = correlationMatrix.length;
                    document.getElementById('correlationResultsCard').style.display = 'block';
                    document.getElementById('teamCardsContainer').style.display = 'block';
                    document.getElementById('positionPairCard').style.display = 'block';
                    
                    // Render all sections
                    renderPositionMatrix(correlationMatrix);
                    renderTeamCards();
                    renderPositionPairTable('QB-WR');
                    
                    console.log('Correlations restored from localStorage');
                    return true;
                }
            } catch (e) {
                console.error('Failed to load correlations:', e);
            }
            return false;
        }
        
        function organizeByTeam(correlations) {
            teamCorrelations = {};
            
            correlations.forEach(corr => {
                if (!teamCorrelations[corr.team]) {
                    teamCorrelations[corr.team] = [];
                }
                teamCorrelations[corr.team].push(corr);
            });
            
            // Sort each team's correlations
            Object.keys(teamCorrelations).forEach(team => {
                teamCorrelations[team].sort((a, b) => b.correlation - a.correlation);
            });
        }
        
        function organizeByPositionPair(correlations) {
            positionPairCorrelations = {};
            
            correlations.forEach(corr => {
                // Create normalized pair key (alphabetical order)
                const pair = [corr.pos1, corr.pos2].sort().join('-');
                
                if (!positionPairCorrelations[pair]) {
                    positionPairCorrelations[pair] = [];
                }
                positionPairCorrelations[pair].push(corr);
            });
            
            // Sort each pair's correlations
            Object.keys(positionPairCorrelations).forEach(pair => {
                positionPairCorrelations[pair].sort((a, b) => b.correlation - a.correlation);
            });
        }
        
        function renderPositionMatrix(correlations) {
            // Calculate average correlation for each position pair
            const pairAverages = {};
            const pairCounts = {};
            
            correlations.forEach(corr => {
                const pair = [corr.pos1, corr.pos2].sort().join('-');
                if (!pairAverages[pair]) {
                    pairAverages[pair] = 0;
                    pairCounts[pair] = 0;
                }
                pairAverages[pair] += corr.correlation;
                pairCounts[pair]++;
            });
            
            Object.keys(pairAverages).forEach(pair => {
                pairAverages[pair] = pairAverages[pair] / pairCounts[pair];
            });
            
            const posOrder = ['QB', 'RB', 'WR', 'TE', 'DST'];
            const matrix = document.getElementById('positionMatrix');
            
            let html = `
                <div class="matrix-cell header"></div>
                <div class="matrix-cell header">QB</div>
                <div class="matrix-cell header">RB</div>
                <div class="matrix-cell header">WR</div>
                <div class="matrix-cell header">TE</div>
                <div class="matrix-cell header">DST</div>
            `;
            
            posOrder.forEach(pos1 => {
                html += `<div class="matrix-cell row-header">${pos1}</div>`;
                
                posOrder.forEach(pos2 => {
                    if (pos1 === pos2) {
                        html += `<div class="matrix-cell empty">—</div>`;
                    } else {
                        const pair = [pos1, pos2].sort().join('-');
                        const avg = pairAverages[pair];
                        
                        if (avg !== undefined) {
                            let cellClass = 'neutral';
                            if (avg > 0.15) cellClass = 'positive';
                            else if (avg < -0.08) cellClass = 'negative';
                            
                            html += `<div class="matrix-cell ${cellClass}">${avg >= 0 ? '+' : ''}${avg.toFixed(2)}</div>`;
                        } else {
                            html += `<div class="matrix-cell empty">—</div>`;
                        }
                    }
                });
            });
            
            matrix.innerHTML = html;
        }
        
        function renderTeamCards() {
            const grid = document.getElementById('teamCardsGrid');
            const teams = Object.keys(teamCorrelations).sort();
            
            let html = '';
            
            teams.forEach(teamAbbr => {
                const teamInfo = NFL_TEAMS[teamAbbr] || { name: teamAbbr, primary: '#666666', logo: '' };
                const corrs = teamCorrelations[teamAbbr];
                
                // Get top QB stacks (positive correlations with QB)
                const qbStacks = corrs.filter(c => 
                    (c.pos1 === 'QB' || c.pos2 === 'QB') && c.correlation > 0.2
                ).slice(0, 3);
                
                // Get correlations to avoid (negative)
                const avoidPairs = corrs.filter(c => c.correlation < -0.15).slice(0, 2);
                
                html += `
                    <div class="team-card" data-team="${teamAbbr}" onclick="showTeamDetail('${teamAbbr}')">
                        <div class="team-card-header" style="border-bottom-color: ${teamInfo.primary};">
                            <img class="team-logo" src="${teamInfo.logo}" alt="${teamInfo.name}" onerror="this.style.display='none'">
                            <div class="team-info">
                                <h4>${teamInfo.city || ''} ${teamInfo.name}</h4>
                                <span>${corrs.length} correlations</span>
                            </div>
                        </div>
                        <div class="team-card-body">
                            <div class="team-corr-section">
                                <div class="team-corr-label">
                                    <span style="color: var(--accent-primary);">●</span> Best QB Stacks
                                </div>
                                ${qbStacks.length > 0 ? qbStacks.map(c => {
                                    const nonQB = c.pos1 === 'QB' ? c.player2 : c.player1;
                                    const nonQBPos = c.pos1 === 'QB' ? c.pos2 : c.pos1;
                                    return `
                                        <div class="team-corr-item">
                                            <span class="player-name">${nonQB} (${nonQBPos})</span>
                                            <span class="corr-value positive">+${c.correlation.toFixed(2)}</span>
                                        </div>
                                    `;
                                }).join('') : '<div class="team-corr-item"><span class="player-name" style="color:var(--text-muted);">No strong stacks</span></div>'}
                            </div>
                            ${avoidPairs.length > 0 ? `
                                <div class="team-corr-section">
                                    <div class="team-corr-label">
                                        <span style="color: var(--accent-danger);">●</span> Avoid Pairing
                                    </div>
                                    ${avoidPairs.map(c => `
                                        <div class="team-corr-item">
                                            <span class="player-name">${c.player1.split(' ').pop()} / ${c.player2.split(' ').pop()}</span>
                                            <span class="corr-value negative">${c.correlation.toFixed(2)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
            
            grid.innerHTML = html;
        }
        
        function showTeamDetail(teamAbbr) {
            const teamInfo = NFL_TEAMS[teamAbbr] || { name: teamAbbr, primary: '#666666', logo: '' };
            const corrs = teamCorrelations[teamAbbr];
            
            // Update header
            document.getElementById('teamDetailLogo').src = teamInfo.logo;
            document.getElementById('teamDetailName').textContent = `${teamInfo.city || ''} ${teamInfo.name}`;
            document.getElementById('teamDetailHeader').style.borderBottomColor = teamInfo.primary;
            
            // Group correlations by type
            const qbCorrs = corrs.filter(c => c.pos1 === 'QB' || c.pos2 === 'QB');
            const wrwrCorrs = corrs.filter(c => c.pos1 === 'WR' && c.pos2 === 'WR');
            const rbCorrs = corrs.filter(c => (c.pos1 === 'RB' || c.pos2 === 'RB') && c.pos1 !== 'QB' && c.pos2 !== 'QB');
            const teCorrs = corrs.filter(c => (c.pos1 === 'TE' || c.pos2 === 'TE') && c.pos1 !== 'QB' && c.pos2 !== 'QB');
            
            let html = '';
            
            // QB Correlations Section
            if (qbCorrs.length > 0) {
                html += `
                    <div class="team-detail-section">
                        <h3>
                            <span class="pd-position-badge qb" style="font-size:0.7rem;padding:3px 8px;">QB</span>
                            Quarterback Correlations
                        </h3>
                        <div class="detail-corr-list">
                            ${qbCorrs.map(c => {
                                const qb = c.pos1 === 'QB' ? c.player1 : c.player2;
                                const other = c.pos1 === 'QB' ? c.player2 : c.player1;
                                const otherPos = c.pos1 === 'QB' ? c.pos2 : c.pos1;
                                const corrClass = c.correlation >= 0 ? 'positive' : 'negative';
                                const barWidth = Math.abs(c.correlation) * 100;
                                return `
                                    <div class="detail-corr-row">
                                        <div>${qb}</div>
                                        <div>
                                            <span class="pd-position-badge ${otherPos.toLowerCase()}" style="font-size:0.6rem;padding:2px 5px;margin-right:4px;">${otherPos}</span>
                                            ${other}
                                        </div>
                                        <div>
                                            <div class="corr-bar-container">
                                                <div class="corr-bar ${corrClass}" style="width: ${barWidth}%;"></div>
                                            </div>
                                        </div>
                                        <div><span class="correlation-value ${corrClass}">${c.correlation >= 0 ? '+' : ''}${c.correlation.toFixed(3)}</span></div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // WR-WR Section
            if (wrwrCorrs.length > 0) {
                html += `
                    <div class="team-detail-section">
                        <h3>
                            <span class="pd-position-badge wr" style="font-size:0.7rem;padding:3px 8px;">WR</span>
                            WR vs WR (Same Team Competition)
                        </h3>
                        <div class="detail-corr-list">
                            ${wrwrCorrs.map(c => {
                                const corrClass = c.correlation >= 0 ? 'positive' : 'negative';
                                const barWidth = Math.abs(c.correlation) * 100;
                                return `
                                    <div class="detail-corr-row">
                                        <div>${c.player1}</div>
                                        <div>${c.player2}</div>
                                        <div>
                                            <div class="corr-bar-container">
                                                <div class="corr-bar ${corrClass}" style="width: ${barWidth}%;"></div>
                                            </div>
                                        </div>
                                        <div><span class="correlation-value ${corrClass}">${c.correlation >= 0 ? '+' : ''}${c.correlation.toFixed(3)}</span></div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // RB Correlations Section
            if (rbCorrs.length > 0) {
                html += `
                    <div class="team-detail-section">
                        <h3>
                            <span class="pd-position-badge rb" style="font-size:0.7rem;padding:3px 8px;">RB</span>
                            Running Back Correlations
                        </h3>
                        <div class="detail-corr-list">
                            ${rbCorrs.slice(0, 10).map(c => {
                                const corrClass = c.correlation >= 0 ? 'positive' : 'negative';
                                const barWidth = Math.abs(c.correlation) * 100;
                                return `
                                    <div class="detail-corr-row">
                                        <div>
                                            <span class="pd-position-badge ${c.pos1.toLowerCase()}" style="font-size:0.6rem;padding:2px 5px;margin-right:4px;">${c.pos1}</span>
                                            ${c.player1}
                                        </div>
                                        <div>
                                            <span class="pd-position-badge ${c.pos2.toLowerCase()}" style="font-size:0.6rem;padding:2px 5px;margin-right:4px;">${c.pos2}</span>
                                            ${c.player2}
                                        </div>
                                        <div>
                                            <div class="corr-bar-container">
                                                <div class="corr-bar ${corrClass}" style="width: ${barWidth}%;"></div>
                                            </div>
                                        </div>
                                        <div><span class="correlation-value ${corrClass}">${c.correlation >= 0 ? '+' : ''}${c.correlation.toFixed(3)}</span></div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('teamDetailBody').innerHTML = html;
            document.getElementById('teamDetailOverlay').classList.add('active');
        }
        
        function renderPositionPairTable(pair) {
            const table = document.getElementById('positionPairTable');
            
            // Normalize pair for lookup
            const normalizedPair = pair.split('-').sort().join('-');
            const corrs = positionPairCorrelations[normalizedPair] || [];
            
            const top50 = corrs.slice(0, 50);
            
            let html = `
                <div class="correlation-row header">
                    <div>Player 1</div>
                    <div>Player 2</div>
                    <div>Team</div>
                    <div>Correlation</div>
                </div>
            `;
            
            top50.forEach(corr => {
                const corrClass = corr.correlation >= 0 ? 'positive' : 'negative';
                const teamInfo = NFL_TEAMS[corr.team] || { name: corr.team, primary: '#666666' };
                html += `
                    <div class="correlation-row">
                        <div>
                            <span class="pd-position-badge ${corr.pos1.toLowerCase()}" style="font-size:0.65rem;padding:2px 6px;margin-right:6px;">${corr.pos1}</span>
                            ${corr.player1}
                        </div>
                        <div>
                            <span class="pd-position-badge ${corr.pos2.toLowerCase()}" style="font-size:0.65rem;padding:2px 6px;margin-right:6px;">${corr.pos2}</span>
                            ${corr.player2}
                        </div>
                        <div style="color: ${teamInfo.primary}; font-weight: 600;">${corr.team}</div>
                        <div><span class="correlation-value ${corrClass}">${corr.correlation >= 0 ? '+' : ''}${corr.correlation.toFixed(3)}</span></div>
                    </div>
                `;
            });
            
            if (top50.length === 0) {
                html += `<div style="padding: 20px; text-align: center; color: var(--text-muted);">No correlations found for this position pair</div>`;
            }
            
            table.innerHTML = html;
        }
        
        function pearsonCorrelation(x, y) {
            const n = x.length;
            if (n < 3) return null;
            
            const meanX = x.reduce((a, b) => a + b, 0) / n;
            const meanY = y.reduce((a, b) => a + b, 0) / n;
            
            let numerator = 0;
            let sumSqX = 0;
            let sumSqY = 0;
            
            for (let i = 0; i < n; i++) {
                const dx = x[i] - meanX;
                const dy = y[i] - meanY;
                numerator += dx * dy;
                sumSqX += dx * dx;
                sumSqY += dy * dy;
            }
            
            if (sumSqX === 0 || sumSqY === 0) return null;
            
            return numerator / Math.sqrt(sumSqX * sumSqY);
        }
        
        // Position Pair Tab clicks
        document.querySelectorAll('.position-pair-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.position-pair-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                renderPositionPairTable(tab.dataset.pair);
            });
        });
        
        // Team Detail Modal close handlers
        document.getElementById('teamDetailClose').addEventListener('click', () => {
            document.getElementById('teamDetailOverlay').classList.remove('active');
        });
        
        document.getElementById('teamDetailOverlay').addEventListener('click', (e) => {
            if (e.target === document.getElementById('teamDetailOverlay')) {
                document.getElementById('teamDetailOverlay').classList.remove('active');
            }
        });

        // Initialize: Load stored correlations on page load
        // (Raw player data is not persisted - too large for localStorage)
        loadCorrelationsFromStorage();

        // ==========================================
        // CLASSIC OPTIMIZER FUNCTIONALITY
        // ==========================================

        // Classic State
        let classicPlayers = [];
        let classicEntries = [];
        let classicSlates = {};
        let classicCurrentSlate = null;
        let classicSelectedLineupCount = 100;
        let classicSelectedTimeSeconds = null;
        let classicMinSalary = 45000;
        let classicMaxSalary = 50000;
        let classicProjFloor = 90;
        let classicOptimizerMode = 'paw-patrol';
        let classicDiversity = 5;
        const CLASSIC_SALARY_CAP = 50000;

        // Classic time mapping - 2 slates with 3 games each
        // Slate 1: 12:00 PM, 2:00 PM, 4:00 PM games
        // Slate 2: 6:00 PM, 8:00 PM, 10:00 PM games
        const classicSlateTimeMap = {
            '12:00': 1, '12:30': 1,
            '14:00': 1, '14:30': 1, '2:00': 1,
            '16:00': 1, '16:30': 1, '4:00': 1,
            '18:00': 2, '18:30': 2, '6:00': 2,
            '20:00': 2, '20:30': 2, '8:00': 2, '20:15': 2, '20:20': 2,
            '22:00': 2, '22:30': 2, '10:00': 2
        };

        // Classic Upload Zone
        const classicUploadZone = document.getElementById('classicUploadZone');
        const classicCsvInput = document.getElementById('classicCsvInput');

        classicUploadZone.addEventListener('click', () => classicCsvInput.click());
        classicUploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            classicUploadZone.classList.add('dragover');
        });
        classicUploadZone.addEventListener('dragleave', () => {
            classicUploadZone.classList.remove('dragover');
        });
        classicUploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            classicUploadZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.csv')) {
                handleClassicCSV(file);
            }
        });
        classicCsvInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleClassicCSV(file);
            classicCsvInput.value = '';
        });

        function handleClassicCSV(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                parseClassicCSV(e.target.result);
                classicUploadZone.innerHTML = `
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" style="color: var(--accent-primary);">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <h3 style="color: var(--accent-primary);">✓ ${file.name}</h3>
                    <p>${classicEntries.length} entries, ${classicPlayers.length} players</p>
                `;
            };
            reader.readAsText(file);
        }

        function parseClassicCSV(csvData) {
            const lines = csvData.split('\n');
            classicEntries = [];
            classicPlayers = [];
            classicSlates = {};

            let inPlayerSection = false;

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                const row = parseCSVLine(line);
                
                // Detect player section (columns 14+ have position data)
                if (row.length > 14 && row[14] && ['QB', 'RB', 'WR', 'TE', 'DST', 'K'].includes(row[14].toUpperCase())) {
                    inPlayerSection = true;
                }

                if (inPlayerSection) {
                    // Player row: cols 14-22 contain player data
                    const position = row[14]?.trim().toUpperCase();
                    const nameWithId = row[15]?.trim();
                    const name = row[16]?.trim();
                    const playerId = row[17]?.trim();
                    const rosterPos = row[18]?.trim();
                    const salary = parseInt(row[19]) || 0;
                    const game = row[20]?.trim() || '';
                    const team = row[21]?.trim().toUpperCase() || '';
                    const projection = parseFloat(row[22]) || 0;

                    if (!name || !position || !salary) continue;

                    // Determine slate from game time
                    let slateNum = 1;
                    const timeMatch = game.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (timeMatch) {
                        let hour = parseInt(timeMatch[1]);
                        const minutes = timeMatch[2];
                        const ampm = timeMatch[3].toUpperCase();
                        if (ampm === 'PM' && hour !== 12) hour += 12;
                        if (ampm === 'AM' && hour === 12) hour = 0;
                        const timeKey = `${hour}:${minutes}`;
                        slateNum = classicSlateTimeMap[timeKey] || classicSlateTimeMap[`${hour}:00`] || 1;
                    }

                    const player = {
                        id: playerId,
                        name,
                        nameWithId,
                        position: position === 'D' || position === 'DEF' ? 'DST' : position,
                        salary,
                        projection,
                        team,
                        game,
                        slateNum,
                        value: salary > 0 ? projection / (salary / 1000) : 0
                    };

                    classicPlayers.push(player);

                    if (!classicSlates[slateNum]) {
                        classicSlates[slateNum] = { entries: [], players: [], lineups: [], gameInfo: game };
                    }
                    classicSlates[slateNum].players.push(player);

                } else if (row[0] && row[0].match(/^\d+$/)) {
                    // Entry row
                    const entry = {
                        entryId: row[0],
                        contestName: row[1] || '',
                        contestId: row[2] || '',
                        entryFee: parseFloat(row[3]?.replace('$', '')) || 0,
                        slots: row.slice(4, 13),
                        lineup: null,
                        slateNum: 1
                    };

                    // Determine slate from contest name
                    const timeMatch = entry.contestName.match(/(\d{1,2}):(\d{2})\s*(AM|PM)/i);
                    if (timeMatch) {
                        let hour = parseInt(timeMatch[1]);
                        const minutes = timeMatch[2];
                        const ampm = timeMatch[3].toUpperCase();
                        if (ampm === 'PM' && hour !== 12) hour += 12;
                        if (ampm === 'AM' && hour === 12) hour = 0;
                        const timeKey = `${hour}:${minutes}`;
                        entry.slateNum = classicSlateTimeMap[timeKey] || classicSlateTimeMap[`${hour}:00`] || 1;
                    }

                    classicEntries.push(entry);

                    if (!classicSlates[entry.slateNum]) {
                        classicSlates[entry.slateNum] = { entries: [], players: [], lineups: [], gameInfo: '' };
                    }
                    classicSlates[entry.slateNum].entries.push(entry);
                }
            }

            document.getElementById('classicEntriesLoaded').textContent = classicEntries.length;
            document.getElementById('classicPlayersLoaded').textContent = classicPlayers.length;

            // Log parsing summary
            console.log('=== CLASSIC CSV PARSING COMPLETE ===');
            console.log('Total entries:', classicEntries.length);
            console.log('Total players:', classicPlayers.length);
            Object.keys(classicSlates).forEach(slateNum => {
                const slate = classicSlates[slateNum];
                console.log(`Slate ${slateNum}: ${slate.entries.length} entries, ${slate.players.length} players`);
                const positions = {};
                slate.players.forEach(p => {
                    positions[p.position] = (positions[p.position] || 0) + 1;
                });
                console.log('  Positions:', positions);
            });

            updateClassicSlateButtons();
            
            // Auto-select first slate with data (Classic has 2 slates)
            for (let i = 1; i <= 2; i++) {
                if (classicSlates[i] && classicSlates[i].players.length > 0) {
                    selectClassicSlate(i);
                    break;
                }
            }
        }

        function updateClassicSlateButtons() {
            const container = document.getElementById('classicSlateSelector');
            if (!container) return;
            const buttons = container.querySelectorAll('.slate-btn');
            
            buttons.forEach(btn => {
                const slateNum = parseInt(btn.dataset.slate);
                const slate = classicSlates[slateNum];
                
                if (slate && (slate.entries.length > 0 || slate.players.length > 0)) {
                    btn.classList.add('has-data');
                } else {
                    btn.classList.remove('has-data');
                }
            });
        }

        function selectClassicSlate(slateNum) {
            classicCurrentSlate = slateNum;
            
            document.querySelectorAll('#classicSlateSelector .slate-btn').forEach(btn => {
                btn.classList.toggle('active', parseInt(btn.dataset.slate) === slateNum);
            });

            const slate = classicSlates[slateNum];
            if (slate) {
                document.getElementById('classicSlateBadge').textContent = slateNum;
                document.getElementById('classicSlatePlayerCount').textContent = slate.players.length;
                document.getElementById('classicSlateEntryCount').textContent = slate.entries.length;
                
                // Extract all unique games from players
                const uniqueGames = [...new Set(slate.players.map(p => p.game).filter(g => g))];
                const teams = new Set();
                uniqueGames.forEach(game => {
                    const match = game.match(/([A-Z]{2,3})@([A-Z]{2,3})/);
                    if (match) {
                        teams.add(match[1]);
                        teams.add(match[2]);
                    }
                });
                
                const teamsArray = [...teams];
                document.getElementById('classicSlateTeams').textContent = teamsArray.length > 0 
                    ? `${teamsArray.length} teams (${uniqueGames.length} games)` 
                    : 'No games';
                document.getElementById('classicSlateDateTime').textContent = slateNum === 1 ? 'Early Slate' : 'Late Slate';

                const poolBadge = document.getElementById('classicPlayerPoolSlateBadge');
                const entriesBadge = document.getElementById('classicEntriesSlateBadge');
                if (poolBadge) poolBadge.textContent = `Slate ${slateNum}`;
                if (entriesBadge) entriesBadge.textContent = `Slate ${slateNum}`;
            }

            renderClassicPlayerPool();
            renderClassicEntries();
            updateClassicUI();
        }

        document.querySelectorAll('#classicSlateSelector .slate-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                selectClassicSlate(parseInt(btn.dataset.slate));
            });
        });

        function updateClassicUI() {
            const hasPlayers = classicCurrentSlate && classicSlates[classicCurrentSlate]?.players.length > 0;
            const generateBtn = document.getElementById('classicGenerateBtn');
            if (generateBtn) generateBtn.disabled = !hasPlayers;
            
            const hasEntries = classicCurrentSlate && classicSlates[classicCurrentSlate]?.entries.length > 0;
            const entriesCard = document.getElementById('classicEntriesCard');
            const optimizeCard = document.getElementById('classicOptimizeCard');
            if (entriesCard) entriesCard.style.display = hasEntries ? 'block' : 'none';
            if (optimizeCard) optimizeCard.style.display = hasPlayers ? 'block' : 'none';
        }

        function renderClassicPlayerPool() {
            const container = document.getElementById('classicPlayerPoolContainer');
            if (!container) return;
            
            if (!classicCurrentSlate || !classicSlates[classicCurrentSlate]) {
                container.innerHTML = `<div class="empty-state"><h4>No Players Loaded</h4><p>Upload a CSV file</p></div>`;
                return;
            }

            const players = classicSlates[classicCurrentSlate].players;
            const searchInput = document.getElementById('classicPlayerSearch');
            const searchTerm = searchInput?.value?.toLowerCase() || '';
            const activeFilter = document.querySelector('#classicPositionFilters .filter-pill.active')?.dataset.pos || 'all';

            let filtered = players.filter(p => {
                const matchesSearch = p.name.toLowerCase().includes(searchTerm) || 
                                      p.team.toLowerCase().includes(searchTerm);
                const matchesPosition = activeFilter === 'all' || p.position === activeFilter;
                return matchesSearch && matchesPosition;
            });

            filtered.sort((a, b) => b.projection - a.projection);
            const playerCountEl = document.getElementById('classicPlayerCount');
            if (playerCountEl) playerCountEl.textContent = filtered.length;

            if (filtered.length === 0) {
                container.innerHTML = `<div class="empty-state"><h4>No players match filters</h4></div>`;
                return;
            }

            let html = `<table class="player-table"><thead><tr>
                <th>Player</th><th>Pos</th><th>Team</th><th>Salary</th><th>Proj</th><th>Value</th>
            </tr></thead><tbody>`;

            filtered.slice(0, 100).forEach(p => {
                html += `<tr>
                    <td>${p.name}</td>
                    <td><span class="position-badge ${p.position.toLowerCase()}">${p.position}</span></td>
                    <td>${p.team}</td>
                    <td>$${p.salary.toLocaleString()}</td>
                    <td style="color: var(--accent-primary); font-weight: 600;">${p.projection.toFixed(1)}</td>
                    <td style="color: var(--text-muted);">${p.value.toFixed(2)}</td>
                </tr>`;
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function renderClassicEntries() {
            const container = document.getElementById('classicEntriesGroupedContainer');
            if (!container || !classicCurrentSlate || !classicSlates[classicCurrentSlate]) return;

            const entries = classicSlates[classicCurrentSlate].entries;
            if (entries.length === 0) {
                container.innerHTML = '';
                return;
            }

            const grouped = {};
            entries.forEach(e => {
                const key = e.contestName;
                if (!grouped[key]) grouped[key] = { entries: [], totalFee: 0 };
                grouped[key].entries.push(e);
                grouped[key].totalFee += e.entryFee;
            });

            let html = '';
            Object.keys(grouped).forEach(contestName => {
                const group = grouped[contestName];
                html += `<div class="entries-group">
                    <div class="entries-group-header">
                        <span class="contest-name">${contestName}</span>
                        <span class="contest-meta">${group.entries.length} entries • $${group.totalFee.toFixed(2)}</span>
                    </div>
                </div>`;
            });

            container.innerHTML = html;

            const totalFees = entries.reduce((sum, e) => sum + e.entryFee, 0);
            const countEl = document.getElementById('classicEntriesCount');
            const feesEl = document.getElementById('classicTotalEntryFees');
            if (countEl) countEl.textContent = `${entries.length} entries`;
            if (feesEl) feesEl.textContent = `$${totalFees.toFixed(2)} total`;
        }

        document.querySelectorAll('#classicPositionFilters .filter-pill').forEach(pill => {
            pill.addEventListener('click', () => {
                document.querySelectorAll('#classicPositionFilters .filter-pill').forEach(p => p.classList.remove('active'));
                pill.classList.add('active');
                renderClassicPlayerPool();
            });
        });

        document.getElementById('classicPlayerSearch')?.addEventListener('input', renderClassicPlayerPool);

        document.getElementById('classicMinSalarySlider')?.addEventListener('input', (e) => {
            classicMinSalary = parseInt(e.target.value);
            if (classicMinSalary > classicMaxSalary) {
                classicMaxSalary = classicMinSalary;
                document.getElementById('classicMaxSalarySlider').value = classicMaxSalary;
            }
            document.getElementById('classicMinSalaryValue').textContent = classicMinSalary.toLocaleString();
            document.getElementById('classicMaxSalaryValue').textContent = classicMaxSalary.toLocaleString();
        });

        document.getElementById('classicMaxSalarySlider')?.addEventListener('input', (e) => {
            classicMaxSalary = parseInt(e.target.value);
            if (classicMaxSalary < classicMinSalary) {
                classicMinSalary = classicMaxSalary;
                document.getElementById('classicMinSalarySlider').value = classicMinSalary;
            }
            document.getElementById('classicMinSalaryValue').textContent = classicMinSalary.toLocaleString();
            document.getElementById('classicMaxSalaryValue').textContent = classicMaxSalary.toLocaleString();
        });

        document.getElementById('classicProjFloorSlider')?.addEventListener('input', (e) => {
            classicProjFloor = parseFloat(e.target.value);
            document.getElementById('classicProjFloorValue').textContent = `${classicProjFloor.toFixed(1)}%`;
        });

        document.querySelectorAll('#classicLineupCountBtns .lineup-count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#classicLineupCountBtns .lineup-count-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('#classicTimeBtns .lineup-time-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                classicSelectedLineupCount = parseInt(btn.dataset.count);
                classicSelectedTimeSeconds = null;
            });
        });

        document.querySelectorAll('#classicTimeBtns .lineup-time-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#classicLineupCountBtns .lineup-count-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('#classicTimeBtns .lineup-time-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                classicSelectedTimeSeconds = parseInt(btn.dataset.seconds);
            });
        });

        document.querySelectorAll('#classicOptimizeModes .optimize-mode-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('#classicOptimizeModes .optimize-mode-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                classicOptimizerMode = btn.dataset.mode;
                const pawSettings = document.getElementById('classicPawPatrolSettings');
                if (pawSettings) pawSettings.style.display = classicOptimizerMode === 'paw-patrol' ? 'block' : 'none';
            });
        });

        document.getElementById('classicDiversitySlider')?.addEventListener('input', (e) => {
            classicDiversity = parseInt(e.target.value);
            document.getElementById('classicDiversityValue').textContent = classicDiversity;
        });

        document.getElementById('classicGenerateBtn')?.addEventListener('click', () => {
            generateClassicLineups(classicCurrentSlate);
        });

        document.getElementById('classicProcessAllBtn')?.addEventListener('click', async () => {
            const btn = document.getElementById('classicProcessAllBtn');
            btn.disabled = true;
            
            for (const slateNum of Object.keys(classicSlates)) {
                if (classicSlates[slateNum].players.length > 0) {
                    selectClassicSlate(parseInt(slateNum));
                    await generateClassicLineups(parseInt(slateNum));
                    await new Promise(r => setTimeout(r, 100));
                }
            }
            
            btn.disabled = false;
        });

        async function generateClassicLineups(slateNum) {
            const slate = classicSlates[slateNum];
            if (!slate || slate.players.length === 0) return;

            const progressContainer = document.getElementById('classicProgressContainer');
            const progressFill = document.getElementById('classicProgressFill');
            const progressText = document.getElementById('classicProgressText');

            progressContainer.style.display = 'block';
            progressFill.style.width = '0%';
            document.getElementById('classicGenerateBtn').disabled = true;

            const players = slate.players;
            
            // Add value metric to each player
            players.forEach(p => {
                p.value = p.salary > 0 ? (p.projection / p.salary) * 1000 : 0;
            });

            // Organize by position
            const byPosition = {
                QB: players.filter(p => p.position === 'QB').sort((a,b) => b.projection - a.projection),
                RB: players.filter(p => p.position === 'RB').sort((a,b) => b.projection - a.projection),
                WR: players.filter(p => p.position === 'WR').sort((a,b) => b.projection - a.projection),
                TE: players.filter(p => p.position === 'TE').sort((a,b) => b.projection - a.projection),
                DST: players.filter(p => p.position === 'DST').sort((a,b) => b.projection - a.projection),
                FLEX: players.filter(p => ['RB', 'WR', 'TE'].includes(p.position)).sort((a,b) => b.projection - a.projection)
            };

            console.log('=== CLASSIC LINEUP GENERATION ===');
            console.log('Position counts:', {
                QB: byPosition.QB.length,
                RB: byPosition.RB.length,
                WR: byPosition.WR.length,
                TE: byPosition.TE.length,
                DST: byPosition.DST.length,
                FLEX: byPosition.FLEX.length
            });

            const generated = [];
            const lineupSet = new Set();
            const startTime = Date.now();
            const targetCount = classicSelectedTimeSeconds ? 50000 : classicSelectedLineupCount;
            const maxTime = classicSelectedTimeSeconds ? classicSelectedTimeSeconds * 1000 : 30000;

            // Strategies to rotate through
            const strategies = ['high_value', 'high_projection', 'high_value', 'high_ceiling', 'balanced', 'high_value', 'stacking'];

            // Discovery phase - find max projection
            progressText.textContent = 'Discovery: Finding max projection...';
            let discoveredMax = 0;
            
            for (let i = 0; i < 500; i++) {
                const lineup = buildClassicLineupByStrategy(byPosition, 'high_projection');
                if (lineup && lineup.totalProjection > discoveredMax) {
                    discoveredMax = lineup.totalProjection;
                }
            }

            // Set projection floor as percentage of discovered max
            const projectionFloor = discoveredMax * (classicProjFloor / 100);
            // Salary floor is 96% of cap
            const salaryFloor = CLASSIC_SALARY_CAP * 0.96;

            console.log('Discovery complete:', {
                maxProjection: discoveredMax.toFixed(2),
                projectionFloor: projectionFloor.toFixed(2),
                salaryFloor: salaryFloor
            });

            let strategyIndex = 0;
            let buildStats = { attempts: 0, duplicates: 0, belowProjFloor: 0, belowSalaryFloor: 0, success: 0 };

            // Phase 1: Pure projection lineups (first 5 seconds or 40% of lineups)
            const phase1End = Math.min(startTime + 5000, startTime + maxTime * 0.4);
            progressText.textContent = 'Phase 1: Building high projection lineups...';

            while (Date.now() < phase1End && generated.length < targetCount) {
                buildStats.attempts++;
                const strategy = strategies[strategyIndex % strategies.length];
                if (buildStats.attempts % 30 === 0) strategyIndex++;

                const lineup = buildClassicLineupByStrategy(byPosition, strategy);
                
                if (lineup) {
                    const key = lineup.players.map(p => p.id).sort().join('|');
                    
                    if (lineupSet.has(key)) {
                        buildStats.duplicates++;
                    } else if (lineup.totalProjection < projectionFloor) {
                        buildStats.belowProjFloor++;
                    } else if (lineup.totalSalary < salaryFloor) {
                        buildStats.belowSalaryFloor++;
                    } else {
                        lineupSet.add(key);
                        lineup.phase = 1;
                        lineup.strategy = strategy;
                        generated.push(lineup);
                        buildStats.success++;
                    }
                }

                if (buildStats.attempts % 200 === 0) {
                    const progress = Math.min((Date.now() - startTime) / maxTime * 100, 100);
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Phase 1: ${generated.length} lineups...`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            console.log('Phase 1 complete:', generated.length, 'lineups');

            // Phase 2: Correlation-aware stacking (remaining time)
            progressText.textContent = 'Phase 2: Building correlated stacks...';

            while (Date.now() - startTime < maxTime && generated.length < targetCount) {
                buildStats.attempts++;
                
                // Emphasize stacking in phase 2
                const phase2Strategies = ['stacking', 'stacking', 'high_value', 'balanced', 'stacking'];
                const strategy = phase2Strategies[strategyIndex % phase2Strategies.length];
                if (buildStats.attempts % 25 === 0) strategyIndex++;

                const lineup = buildClassicLineupByStrategy(byPosition, strategy);
                
                if (lineup) {
                    const key = lineup.players.map(p => p.id).sort().join('|');
                    
                    if (lineupSet.has(key)) {
                        buildStats.duplicates++;
                    } else if (lineup.totalProjection < projectionFloor) {
                        buildStats.belowProjFloor++;
                    } else if (lineup.totalSalary < salaryFloor) {
                        buildStats.belowSalaryFloor++;
                    } else {
                        lineupSet.add(key);
                        lineup.phase = 2;
                        lineup.strategy = strategy;
                        generated.push(lineup);
                        buildStats.success++;
                    }
                }

                if (buildStats.attempts % 200 === 0) {
                    const progress = Math.min((Date.now() - startTime) / maxTime * 100, 100);
                    progressFill.style.width = `${progress}%`;
                    progressText.textContent = `Phase 2: ${generated.length} lineups (${strategy})...`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }

            console.log('Build complete:', buildStats);

            // Score and sort lineups
            generated.forEach(lineup => {
                lineup.score = calculateClassicLineupScore(lineup);
            });
            generated.sort((a, b) => b.score.total - a.score.total);

            const finalCount = classicSelectedTimeSeconds ? Math.min(generated.length, 5000) : classicSelectedLineupCount;
            slate.lineups = generated.slice(0, finalCount);

            progressFill.style.width = '100%';
            progressText.textContent = `Generated ${slate.lineups.length} lineups!`;
            
            setTimeout(() => {
                progressContainer.style.display = 'none';
                document.getElementById('classicGenerateBtn').disabled = false;
            }, 1000);

            if (slate.lineups.length > 0) {
                document.getElementById('classicLineupsGenerated').textContent = slate.lineups.length;
                document.getElementById('classicTopProjection').textContent = slate.lineups[0].totalProjection.toFixed(2);
                const avgScore = slate.lineups.reduce((sum, l) => sum + l.score.total, 0) / slate.lineups.length;
                document.getElementById('classicAvgScore').textContent = avgScore.toFixed(2);
            }

            renderClassicLineups(slateNum);
            const optimizeBtn = document.getElementById('classicOptimizeBtn');
            if (optimizeBtn) optimizeBtn.disabled = false;
        }

        // Sort players by strategy
        function sortClassicByStrategy(players, strategy) {
            const sorted = [...players];
            switch (strategy) {
                case 'high_projection':
                    return sorted.sort((a, b) => b.projection - a.projection);
                case 'high_value':
                    return sorted.sort((a, b) => (b.value || 0) - (a.value || 0));
                case 'high_ceiling':
                    // Estimate ceiling as projection * 1.5
                    return sorted.sort((a, b) => (b.projection * 1.5) - (a.projection * 1.5));
                case 'stacking':
                case 'balanced':
                default:
                    // Balanced: 50% projection, 50% value
                    return sorted.sort((a, b) => {
                        const scoreA = (a.projection / 30 * 50) + ((a.value || 0) / 5 * 50);
                        const scoreB = (b.projection / 30 * 50) + ((b.value || 0) / 5 * 50);
                        return scoreB - scoreA;
                    });
            }
        }

        // Build lineup using specific strategy (MaddenOptimizerV2 approach)
        function buildClassicLineupByStrategy(byPosition, strategy) {
            const lineup = { players: [], totalSalary: 0, totalProjection: 0 };
            const usedPlayers = new Set();
            const teamCounts = {};
            let remainingSalary = CLASSIC_SALARY_CAP;

            // Pick QB first - rotate through top QBs for diversity
            const qbs = byPosition.QB || [];
            if (qbs.length === 0) return null;
            
            const qbPoolSize = Math.min(8, qbs.length);
            const qbIndex = Math.floor(Math.random() * qbPoolSize);
            const qb = qbs[qbIndex];
            
            lineup.players.push({ ...qb, slot: 'QB' });
            usedPlayers.add(qb.id);
            remainingSalary -= qb.salary;
            lineup.totalSalary += qb.salary;
            lineup.totalProjection += qb.projection;
            teamCounts[qb.team] = 1;

            // Determine stacking targets for correlation strategies
            let stackTargets = [];
            const isStackingStrategy = strategy === 'stacking' || Math.random() < 0.6; // 60% chance to stack
            
            if (isStackingStrategy) {
                // Find pass catchers on QB's team
                const teamCatchers = [...(byPosition.WR || []), ...(byPosition.TE || [])]
                    .filter(p => p.team === qb.team)
                    .sort((a, b) => b.projection - a.projection);
                
                // Decide stack count: 1 or 2 targets
                const stackCount = strategy === 'stacking' ? (Math.random() < 0.5 ? 2 : 1) : 
                                   (Math.random() < 0.3 ? 2 : Math.random() < 0.7 ? 1 : 0);
                
                for (let i = 0; i < Math.min(stackCount, teamCatchers.length); i++) {
                    if (teamCatchers[i].salary <= remainingSalary * 0.18) {
                        stackTargets.push(teamCatchers[i]);
                    }
                }
            }

            // Fill positions (shuffle order for diversity)
            const positions = ['DST', 'RB', 'RB', 'WR', 'WR', 'WR', 'TE'];
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (const pos of positions) {
                // Check if any stack target matches this position
                let usedStackTarget = false;
                for (let i = 0; i < stackTargets.length; i++) {
                    const target = stackTargets[i];
                    if (target && !usedPlayers.has(target.id) && target.position === pos) {
                        // Check salary constraint
                        const positionsLeft = 8 - lineup.players.length;
                        const minReserve = positionsLeft * 3000;
                        if (target.salary <= remainingSalary - minReserve) {
                            lineup.players.push({ ...target, slot: pos });
                            usedPlayers.add(target.id);
                            remainingSalary -= target.salary;
                            lineup.totalSalary += target.salary;
                            lineup.totalProjection += target.projection;
                            teamCounts[target.team] = (teamCounts[target.team] || 0) + 1;
                            stackTargets[i] = null; // Mark as used
                            usedStackTarget = true;
                            break;
                        }
                    }
                }

                if (usedStackTarget) continue;

                // Get candidates for this position
                const pool = byPosition[pos] || [];
                const positionsLeft = 8 - lineup.players.length;
                const minReserve = positionsLeft * 3000;
                const maxPlayerSalary = remainingSalary - minReserve;

                const candidates = pool.filter(p => {
                    if (usedPlayers.has(p.id)) return false;
                    if (p.salary > maxPlayerSalary) return false;
                    if (teamCounts[p.team] >= 4) return false; // Max 4 per team
                    return true;
                });

                if (candidates.length === 0) return null;

                // Sort by strategy and pick from top candidates
                const sorted = sortClassicByStrategy(candidates, strategy);
                const selectionSize = strategy === 'high_value' ? 12 : 8;
                const randomRange = strategy === 'high_value' ? 6 : 4;
                const topCandidates = sorted.slice(0, selectionSize);
                const pickIndex = Math.floor(Math.random() * Math.min(randomRange, topCandidates.length));
                const player = topCandidates[pickIndex];

                if (!player) return null;

                lineup.players.push({ ...player, slot: pos });
                usedPlayers.add(player.id);
                remainingSalary -= player.salary;
                lineup.totalSalary += player.salary;
                lineup.totalProjection += player.projection;
                teamCounts[player.team] = (teamCounts[player.team] || 0) + 1;
            }

            // Fill FLEX - check for unused stack targets first
            let flex = null;

            for (const target of stackTargets) {
                if (target && !usedPlayers.has(target.id)) {
                    if (['RB', 'WR', 'TE'].includes(target.position) && target.salary <= remainingSalary) {
                        flex = target;
                        break;
                    }
                }
            }

            if (!flex) {
                const flexCandidates = (byPosition.FLEX || []).filter(p => {
                    if (usedPlayers.has(p.id)) return false;
                    if (p.salary > remainingSalary) return false;
                    if (teamCounts[p.team] >= 4) return false;
                    return true;
                });

                if (flexCandidates.length === 0) return null;

                const sortedFlex = sortClassicByStrategy(flexCandidates, strategy);
                const flexRange = strategy === 'high_value' ? 8 : 5;
                flex = sortedFlex[Math.floor(Math.random() * Math.min(flexRange, sortedFlex.length))];
            }

            if (!flex) return null;

            lineup.players.push({ ...flex, slot: 'FLEX' });
            lineup.totalSalary += flex.salary;
            lineup.totalProjection += flex.projection;

            return lineup;
        }

        function calculateClassicLineupScore(lineup) {
            let projScore = lineup.totalProjection;
            let corrBonus = 0;

            const qb = lineup.players.find(p => p.slot === 'QB');
            if (qb && teamCorrelations[qb.team]) {
                const corrs = teamCorrelations[qb.team];
                lineup.players.forEach(p => {
                    if (p.team === qb.team && p.slot !== 'QB') {
                        const corr = corrs.find(c => 
                            (c.player1 === qb.name && c.player2 === p.name) ||
                            (c.player2 === qb.name && c.player1 === p.name)
                        );
                        if (corr && corr.correlation > 0.2) {
                            corrBonus += corr.correlation * 2;
                        }
                    }
                });
            }

            return { projection: projScore, correlation: corrBonus, total: projScore + corrBonus };
        }

        function renderClassicLineups(slateNum) {
            const slate = classicSlates[slateNum];
            const card = document.getElementById('classicLineupsCard');
            const rows = document.getElementById('classicLineupRows');

            if (!slate || slate.lineups.length === 0) {
                if (card) card.style.display = 'none';
                return;
            }

            if (card) card.style.display = 'block';
            const slateBadge = document.getElementById('classicLineupsSlateBadge');
            const countDisplay = document.getElementById('classicLineupCountDisplay');
            if (slateBadge) slateBadge.textContent = `Slate ${slateNum}`;
            if (countDisplay) countDisplay.textContent = `${slate.lineups.length} lineups`;

            let html = '';
            slate.lineups.slice(0, 100).forEach((lineup, idx) => {
                const qb = lineup.players.find(p => p.slot === 'QB');
                const rbs = lineup.players.filter(p => p.slot === 'RB');
                const wrs = lineup.players.filter(p => p.slot === 'WR');
                const te = lineup.players.find(p => p.slot === 'TE');
                const flex = lineup.players.find(p => p.slot === 'FLEX');
                const dst = lineup.players.find(p => p.position === 'DST');

                const corrClass = lineup.score.correlation >= 0 ? 'positive' : 'negative';

                html += `<div class="classic-lineup-row">
                    <div class="classic-lineup-rank">${idx + 1}</div>
                    <div class="classic-player"><span class="classic-player-name">${qb?.name || '-'}</span><span class="classic-player-info">$${(qb?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${rbs[0]?.name || '-'}</span><span class="classic-player-info">$${(rbs[0]?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${rbs[1]?.name || '-'}</span><span class="classic-player-info">$${(rbs[1]?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${wrs[0]?.name || '-'}</span><span class="classic-player-info">$${(wrs[0]?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${wrs[1]?.name || '-'}</span><span class="classic-player-info">$${(wrs[1]?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${wrs[2]?.name || '-'}</span><span class="classic-player-info">$${(wrs[2]?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${te?.name || '-'}</span><span class="classic-player-info">$${(te?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${flex?.name || '-'}</span><span class="classic-player-info">$${(flex?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-player"><span class="classic-player-name">${dst?.name || '-'}</span><span class="classic-player-info">$${(dst?.salary || 0).toLocaleString()}</span></div>
                    <div class="classic-lineup-salary">$${lineup.totalSalary.toLocaleString()}</div>
                    <div class="score-breakdown"><span class="score-proj">${lineup.score.total.toFixed(1)}</span><span class="score-corr ${corrClass}">${lineup.score.correlation >= 0 ? '+' : ''}${lineup.score.correlation.toFixed(1)} corr</span></div>
                </div>`;
            });

            if (rows) rows.innerHTML = html;
        }

        document.getElementById('classicOptimizeBtn')?.addEventListener('click', () => {
            if (!classicCurrentSlate || !classicSlates[classicCurrentSlate]) return;
            const slate = classicSlates[classicCurrentSlate];
            if (slate.lineups.length === 0 || slate.entries.length === 0) return;

            const entries = slate.entries.sort((a, b) => b.entryFee - a.entryFee);
            const lineups = [...slate.lineups];

            if (classicOptimizerMode === 'cash') {
                entries.forEach(e => e.lineup = lineups[0]);
            } else {
                entries.forEach((entry, idx) => {
                    if (lineups.length === 0) return;
                    const pickIndex = Math.min(
                        Math.floor(idx * (10 - classicDiversity) / entries.length * lineups.length / 10),
                        lineups.length - 1
                    );
                    entry.lineup = lineups[pickIndex];
                    if (classicOptimizerMode === 'paw-patrol') {
                        lineups.splice(pickIndex, 1);
                    }
                });
            }

            const statusEl = document.getElementById('classicOptimizeStatus');
            if (statusEl) statusEl.innerHTML = `<span style="color: var(--accent-primary);">✓ ${entries.filter(e => e.lineup).length} entries optimized</span>`;
            const exportBtn = document.getElementById('classicExportEntriesBtn');
            if (exportBtn) exportBtn.disabled = false;
        });

        document.getElementById('classicExportEntriesBtn')?.addEventListener('click', () => {
            if (!classicCurrentSlate || !classicSlates[classicCurrentSlate]) return;
            const slate = classicSlates[classicCurrentSlate];

            let csv = 'Entry ID,Contest Name,Contest ID,Entry Fee,QB,RB,RB,WR,WR,WR,TE,FLEX,DST\n';

            slate.entries.forEach(entry => {
                if (!entry.lineup) return;
                
                const qb = entry.lineup.players.find(p => p.slot === 'QB');
                const rbs = entry.lineup.players.filter(p => p.slot === 'RB');
                const wrs = entry.lineup.players.filter(p => p.slot === 'WR');
                const te = entry.lineup.players.find(p => p.slot === 'TE');
                const flex = entry.lineup.players.find(p => p.slot === 'FLEX');
                const dst = entry.lineup.players.find(p => p.position === 'DST');

                csv += `${entry.entryId},"${entry.contestName}",${entry.contestId},$${entry.entryFee},`;
                csv += `${qb?.nameWithId || ''},${rbs[0]?.nameWithId || ''},${rbs[1]?.nameWithId || ''},`;
                csv += `${wrs[0]?.nameWithId || ''},${wrs[1]?.nameWithId || ''},${wrs[2]?.nameWithId || ''},`;
                csv += `${te?.nameWithId || ''},${flex?.nameWithId || ''},${dst?.nameWithId || ''}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `classic_entries_slate${classicCurrentSlate}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('classicExportBtn')?.addEventListener('click', () => {
            if (!classicCurrentSlate || !classicSlates[classicCurrentSlate]?.lineups.length) return;
            const slate = classicSlates[classicCurrentSlate];

            let csv = 'Rank,QB,RB1,RB2,WR1,WR2,WR3,TE,FLEX,DST,Salary,Score,CorrBonus\n';

            slate.lineups.forEach((lineup, idx) => {
                const qb = lineup.players.find(p => p.slot === 'QB');
                const rbs = lineup.players.filter(p => p.slot === 'RB');
                const wrs = lineup.players.filter(p => p.slot === 'WR');
                const te = lineup.players.find(p => p.slot === 'TE');
                const flex = lineup.players.find(p => p.slot === 'FLEX');
                const dst = lineup.players.find(p => p.position === 'DST');

                csv += `${idx + 1},${qb?.name || ''},${rbs[0]?.name || ''},${rbs[1]?.name || ''},`;
                csv += `${wrs[0]?.name || ''},${wrs[1]?.name || ''},${wrs[2]?.name || ''},`;
                csv += `${te?.name || ''},${flex?.name || ''},${dst?.name || ''},`;
                csv += `${lineup.totalSalary},${lineup.score.total.toFixed(2)},${lineup.score.correlation.toFixed(2)}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `classic_lineups_slate${classicCurrentSlate}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        });

        document.getElementById('classicClearLineupsBtn')?.addEventListener('click', () => {
            if (classicCurrentSlate && classicSlates[classicCurrentSlate]) {
                classicSlates[classicCurrentSlate].lineups = [];
                classicSlates[classicCurrentSlate].entries.forEach(e => e.lineup = null);
                const card = document.getElementById('classicLineupsCard');
                if (card) card.style.display = 'none';
                document.getElementById('classicLineupsGenerated').textContent = '0';
                const optimizeBtn = document.getElementById('classicOptimizeBtn');
                const exportBtn = document.getElementById('classicExportEntriesBtn');
                if (optimizeBtn) optimizeBtn.disabled = true;
                if (exportBtn) exportBtn.disabled = true;
            }
        });
    </script>
</body>
</html>
